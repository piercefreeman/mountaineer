{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Mountaineer \ud83c\udfd4\ufe0f is a framework to easily build webapps in Python and React. If you've used either of these languages before for development, we think you'll be right at home.</p>"},{"location":"#main-features","title":"Main Features","text":"<p>Each framework has its own unique features and tradeoffs. Mountaineer focuses on developer productivity above all else, with production speed a close second.</p> <ul> <li>\ud83d\udcdd Typehints up and down the stack: frontend, backend, and database</li> <li>\ud83c\udf99\ufe0f Trivially easy client&lt;-&gt;server communication, data binding, and function calling</li> <li>\ud83c\udf0e Optimized server rendering for better accessibility and SEO</li> <li>\ud83c\udff9 Static analysis of web pages for strong validation: link validity, data access, etc.</li> <li>\ud83e\udd29 Skip the API or Node.js server just to serve frontend clients</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Head on to the Quickstart for a full guide on setting up and implementing a new Mountaineer webapp. Our \"Learn\" section has a few more guides on how to use Mountaineer to its fullest. Then our \"API\" section has the full docs on all the features and functions available to you.</p>"},{"location":"client_actions/","title":"Client Actions","text":"<p>Conventionally, server mutations that affect a page state are a bit of a hassle. You need to keep track of modified attributes, issue an API call, then reload or merge them into the current page. All of this to mostly just update the state that the original page was initialized with in the first place.</p> <p>Actions are a way to simplify this process. They allow you to define server-side mutations that can be called from the client as if they're regular Javascript functions. Their request and response payloads are typehinted so you can statically verify their behavior.</p>"},{"location":"client_actions/#action-types","title":"Action Types","text":"<p>Anytime clients need to modify the server state, we denote these requests as \"actions\". Internally, they're just POST requests that are sent to the server. There's no black magic to this syntax. You can inspect them all in your browser's console as regular JSON.</p> <p>Your choice of action type depends on how you want to update client data after your server action has been executed.</p> <p>@sideeffect: Update the server data that initialized the client view. Sideeffects are also passthroughs, by definition, so they can pass back arbitrary data that is outside of the scope of the render() data payload. Use a sideeffect whenever the client modifies some data that lives on the server.</p> <p>@passthrough: Expose an action to the client caller but don't update the server data once the action has been completed. Use a passthrough whenever you need to fetch additional data from the server, or the mutation on the server doesn't affect the local frontend state.</p>"},{"location":"client_actions/#side-effect","title":"Side Effect","text":"<p>Side-effects work as if you have reloaded the page. They update the server state and then push the updated state back to the client. They will call a fully fresh <code>render()</code> on the server so you can provide the latest data state to the client. However, unlike a true refresh on the client side, there's no actual browser refresh that is performed. This allows you to receive the updated data definition and keep the rest of your variables saved in local state.</p> <p><code>@sideeffect</code> can either be called with default behavior or customized via decorator arguments:</p> <pre><code># no parameters, refresh all state\n@sideeffect\ndef increment_count(self) -&gt; None:\n    self.global_count += 1\n</code></pre> <pre><code>@sideeffect(\n    # only push the updated current_count variable to the client\n    reload=(CountRender.current_count,)\n)\ndef increment_count(self) -&gt; None:\n    self.global_count += 1\n</code></pre> <pre><code># execute a sideeffect and then return additional data from a custom data model\n@sideeffect\ndef increment_count(self) -&gt; CustomDataModel:\n    self.global_count += 1\n    ...\n    return CustomDataModel(...)\n</code></pre> <p>Keyword arguments can be chained as you expect to customize the sideeffect behavior.</p> <p>You call the sideeffect from the client through the serverState variable:</p> <pre><code>const response = await serverState.increment_count({\n  requestBody: {\n    count: 5,\n  },\n});\n</code></pre> <p>You can also manually inspect the sideeffect payload by accessing <code>response.sideeffect</code>.</p> <p>If the action has a passthrough, it will be supplied in <code>response.passthrough</code>. Otherwise it will be undefined.</p>"},{"location":"client_actions/#experimental-render-reloader","title":"Experimental Render Reloader","text":"<p>Warning</p> <p>This feature is experimental and only supports relatively simple render() function implementations. If you use it for a more complicated render() function and it doesn't work as expected, report a bug to improve the test coverage.</p> <p>Render functions sometimes have heavy logic overhead: they need to fetch multiple objects from the database, do some roll-up computation, etc. If you're issuing a sideeffect that only affects a small portion of the initial data, this is wasted computation.</p> <p>Passing a <code>reload</code> filter to <code>sideeffect</code> prevents this redundant data from being sent to the frontend. But this feature only saves bandwidth; it doesn't actually prevent the server from doing the computation in the first place. This is where the <code>experimental_render_reload</code> comes in.</p> <p>When this flag is set to <code>True</code>, Mountaineer will inspect the AST (Abstract Syntax Tree) of your render function. It creates a new synthetic render function that only does the computation required to calculate the <code>reload</code> parameters. If some intensive compute isn't required for your sideeffect, it will be ignored.</p> <p>We compile this function into the Python runtime so it runs with the same performance as if you had implemented an alternative <code>render()</code> function yourself. Depending on your full render function complexity, this can lead to significant performance improvements.</p> <p>Let's consider the following render function:</p> <pre><code>def render(\n    self,\n    query_id: int,\n) -&gt; ExampleRenderModel:\n    a = calculate_primes(10000)\n    b = calculate_primes(1000000)\n    return ExampleRenderModel(\n        value_a=f\"Hello {a}\",\n        value_b=f\"World {b}\",\n    )\n\n@sideeffect(\n    reload=(ExampleRenderModel.value_a,),\n    experimental_render_reload=use_experimental,\n)\ndef call_sideeffect(self, payload: dict) -&gt; None:\n    pass\n</code></pre> <p>Benchmarked on a Macbook M1, calling this initial render will perform ~1.84s of compute. It results in:</p> <pre><code>{\n  \"value_a\": \"Hello 1229\",\n  \"value_b\": \"Hello 78498\"\n}\n</code></pre> <p>When <code>call_sideeffect</code> is called with <code>experimental_render_reload=True</code>, the compute only takes <code>0.010s</code>. It results in:</p> <pre><code>{\n  \"value_a\": \"Hello 1229\"\n}\n</code></pre>"},{"location":"client_actions/#passthrough","title":"Passthrough","text":"<p>Passthrough is conceptually much simpler, since it doesn't perform any server-&gt;client data syncs once it's finished. Instead, it provides a simple decorator that optionally accepts a ResponseModel:</p> <pre><code># no parameters, no response model\n@passthrough\ndef server_action(self) -&gt; None:\n    pass\n</code></pre> <pre><code># execute a passthrough and then return additional data from a custom data model\n@passthrough\ndef server_action(self) -&gt; CustomDataModel:\n    pass\n</code></pre> <p>Like passthrough values in sideeffects, you can access it on the client side like:</p> <pre><code>const response = await serverState.server_action({});\nconsole.log(response.passthrough);\n</code></pre>"},{"location":"client_actions/#server-events","title":"Server Events","text":"<p>Server-event streams are a useful paradigm in webapp design, and increasing utilized to provide realtime Server-&gt;Client data for use in user notifications, CI feedback, and model inference.</p> <p>Mountaineer supports these natively on the server and client side. Simply decorate your response_model with a <code>typing.AsyncIterator</code> annotation and implement an async generator like you normally do:</p> <pre><code>from typing import AsyncIterator\nfrom mountaineer import passthrough, ControllerBase\nfrom pydantic import BaseModel\n\nclass MyMetadata(BaseModel):\n    state: int\n\nclass MyController(ControllerBase):\n    ...\n\n    @passthrough\n    async def stream_metadata(self) -&gt; AsyncIterator[MyMetadata]:\n        yield MyMetadata(state=1)\n        await asyncio.sleep(10)\n        yield MyMetadata(state=2)\n</code></pre> <p>For the time being we only support server-events in <code>@passthrough</code> functions, not <code>@sideeffect</code>. It's ill-defined whether we should re-render() content every yield or when the iterator has finished. Yielding in passthrough makes it clear that you just want to stream the yielded value to the client.</p> <p>In your frontend, you can iterate over these responses with an async generator loop. Each response object will be parsed into your typed schema for you, so you can see typehints like you would for any regular Mountaineer action.</p> <pre><code>import React, { useState, useEffect } from \"react\";\n\nconst Page = () =&gt; {\n  const [currentState, setCurrentState] = useState(-1);\n\n  useEffect(() =&gt; {\n      const runStream = async () =&gt; {\n        const responseStream = await serverState.stream_metadata({});\n        for await (const response of responseStream) {\n          setCurrentState(response.passthrough.state);\n        }\n      };\n      runStream();\n    }, []);\n\n  return &lt;div&gt;{currentState}&lt;/div&gt;;\n}\n</code></pre> <p>You'll see the first event state <code>1</code> for 10 seconds, then it will update to <code>2</code>.</p>"},{"location":"client_actions/#action-definitions","title":"Action Definitions","text":"<p>When defining your action functions themselves in your controller, we support typehinting via:</p> <ul> <li>Query parameters</li> <li>Pydantic models for JSON payloads</li> <li>Dependency injection via <code>fastapi.Depends</code></li> </ul> <p>We also support both sync and async functions. Sync functions will be spawned into a thread pool by default - which processes them in parallel but can tax system resources with GIL locking. Where possible, use async functions with libraries that support await constructs.</p> <p>A common sideeffect pattern might look like this:</p> <pre><code>from mountaineer import ControllerBase, Depends\nfrom my_website.models import User\nfrom my_website.deps import get_current_user\n\nclass IncrementCountRequest:\n    count: int\n\nclass MyController(ControllerBase):\n    def __init__(self):\n        super().__init__()\n        self.global_count = 0\n\n    @sideeffect\n    async def increment_count(\n        self,\n        payload: IncrementCountRequest,\n        query_param: int,\n        user: User = Depends(get_current_user)\n    ) -&gt; None:\n        self.global_count += payload.count\n</code></pre> <p>Warning</p> <p>Actions are publicly exposed to the Internet by default. It's up to you to secure them with authentication if they should only be accessible by a certain portion of your userbase.</p>"},{"location":"cma/","title":"Create Mountaineer App","text":"<p>Create Mountaineer App \ud83c\udfd4\ufe0f (CMA for short) is a utility that makes it easily to get started on a new Mountaineer project. It provides all the scaffolding files and best practices that you'll need to hit the ground running.</p> <p>Make sure you have pipx installed.</p> <pre><code>$ pipx run create-mountaineer-app\n\n? Project name [my-project]: my_webapp\n? Author [Pierce Freeman &lt;pierce@freeman.vc&gt;] Default\n? Use poetry for dependency management? [Yes] Yes\n? Create stub MVC files? [Yes] Yes\n? Use Tailwind CSS? [Yes] Yes\n? Add editor configuration? [vscode] vscode\n</code></pre> <p>For more details on what files were just created and how to use them, continue to the Structure page.</p>"},{"location":"database/","title":"Database","text":"<p>Mountaineer bundles common conventions for configuring a Postgres database with async connection handlers. This lets it plug and play easily with the async code that you're already writing for your controllers.</p>"},{"location":"database/#config","title":"Config","text":"<p>A configuration class is defined in <code>mountaineer.database</code> that you can use to configure your database connection. Make sure to register your downstream configuration with the <code>DatabaseConfig</code> if you want to use it. For the full list of configuration options and defaults, see the <code>DatabaseConfig</code> superclass.</p> <pre><code>from mountaineer.database import DatabaseConfig\nfrom mountaineer import ConfigBase\n\nclass AppConfig(DatabaseConfig, ConfigBase):\n    POSTGRES_HOST: str\n    POSTGRES_USER: str\n    POSTGRES_PASSWORD: str\n    POSTGRES_DB: str\n    POSTGRES_PORT: int = 5432\n</code></pre> <p>Since database hosts, usernames, and passwords change for development vs. production you'll always want to store these within an <code>.env</code> file in your local directory. During development these will just be injected dynamically via whatever configuration/secrets service you adopt. More on that later.</p>"},{"location":"database/#calling-the-database","title":"Calling the database","text":"<p>Within your render and action functions, you'll have access to the <code>DatabaseDependencies</code>. The main entrypoint here will be the <code>get_db_session</code> dependency, which will give you a new async session to work with. It'll already be opened to a new transaction when your function is called.</p> <p>Transactions are an internal concept of Postgres and most other SQL databases. They let you perform logic in an encapsolated chunk without actually writing their data to the database. This has the benefit that if you have an error partially through your logic, you can just rollback the transaction and the database will be left in the same state it was before you started. You can then try again later without the need to clean up any partial writes.</p> <p><code>SELECT</code> queries don't modify the database state, so these can be executed as-is within action functions.</p> <p>For <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> requests however - these modify the state of the database. So you'll want perform whatever logic you need and commit your changes at the end.</p> <pre><code>from mountaineer.database import DatabaseDependencies\n\nclass HomeController(ControllerBase):\n    ...\n\n    @sideeffect\n    async def add_todo(\n        self,\n        payload: NewTodoRequest,\n        session: AsyncSession = Depends(DatabaseDependencies.get_db_session)\n    ) -&gt; None:\n        new_todo =  TodoItem(description=payload.description)\n        session.add(new_todo)\n        await session.commit()\n</code></pre>"},{"location":"database/#pooling","title":"Pooling","text":"<p>Most webapps are deployed in environments where they have multiple processes running, either on the same machine or separate servers. SQLAlchemy's default pool handling isn't well supported in these situations since it relies on a process-delineated connection pool. By default Mountaineer assumes that you'll deploy your database with a pooler closer to the database itself - something like PgBouncer, Odyssey, or HAProxy.</p>"},{"location":"database_migrations/","title":"Database Migrations","text":"<p>Warning</p> <p>This feature is experimental. Explore using it while developing locally but make sure to backup your data before applying changes. It should support all SQLModel definitions, but if you encounter a bug or lack of support, please report it so we can improve the test coverage.</p>"},{"location":"database_migrations/#overview","title":"Overview","text":"<p>Once your application is in production, you'll need some method of updating your database schema as you update your application's functionality. You could write raw SQL to accomplish these migrations, or manually modify database table definitions. But the former is inconvenient and the second is risky. Mountaineer ships with a migration tool that can automatically generate migration files for you and apply them to your database. Its features:</p> <ul> <li>Fast with no external dependencies outside of Mountaineer core.</li> <li>Zero config required, optional programmatic customization.</li> <li>Unit-testable migration paths that work with normal <code>pytest</code> harnesses.</li> <li>Baked-in support for common Postgres types that overlap with Python, most specifically Enums and datetimes.</li> <li>File-based groundtruth of migration logic, so it can be audited in source control and customized by you.</li> <li>Simple API surface, with atomic Python functions that perform the most common migration operations. Direct database queries (or integration with ORM objects in limited cases) can be used for more complex migration logic.</li> </ul>"},{"location":"database_migrations/#project-integration","title":"Project Integration","text":"<p>Following the current standard for Mountaineer CLI integrations, we require client applications to explicitly define their CLI endpoints. We include basic handlers for import in <code>mountaineer.migrations.cli</code>. This should look very similar to the default handlers for <code>runserver</code> and <code>build</code>.</p> <p>You can integrate like so in your CLI file:</p> myapp/cli.py<pre><code>from click import group, option\n\nfrom mountaineer.io import async_to_sync\nfrom mountaineer.migrations.cli import handle_apply, handle_generate, handle_rollback\nfrom myapp.config import AppConfig\n\n@group\ndef migrate():\n    pass\n\n@migrate.command()\n@option(\"--message\", required=False)\n@async_to_sync\nasync def generate(message: str | None):\n    _ = AppConfig()  # type: ignore\n    await handle_generate(message=message)\n\n@migrate.command()\n@async_to_sync\nasync def apply():\n    _ = AppConfig()  # type: ignore\n    await handle_apply()\n\n@migrate.command()\n@async_to_sync\nasync def rollback():\n    _ = AppConfig()  # type: ignore\n    await handle_rollback()\n</code></pre> <p>Also modify your project's pyproject.toml file.</p> pyproject.toml<pre><code>[tool.poetry.scripts]\nmigrate = \"myapp.cli:migrate\"\n</code></pre>"},{"location":"database_migrations/#generate","title":"Generate","text":"<pre><code>$ poetry run migrate generate --message \"Add author column to article\"\n</code></pre> <p>Generate a migration file, to update the database schema to the ones defined in your code.</p>"},{"location":"database_migrations/#apply","title":"Apply","text":"<pre><code>$ poetry run migrate apply\n</code></pre> <p>Apply all migration files that have not been applied to the database.</p>"},{"location":"database_migrations/#rollback","title":"Rollback","text":"<pre><code>$ poetry run migrate rollback\n</code></pre> <p>Rollback the last migration that was applied to the database.</p>"},{"location":"database_migrations/#migration-files","title":"Migration files","text":"<p>All data changes live in separate migration files. You can generate them through the Mountaineer CLI and modify them as you need to handle your data migrations.</p> <p>The goal of a migration file is to determine the goal database state (ie. what you current have in code). It then figures out how to transition the current database state to the new goal state. As such, before generating your migration file, make sure your local database has the same schema configuration as your production database. Otherwise your migration files might be incorrect and not apply properly.</p> <pre><code>poetry run migrate generate --message \"Add author column to article\"\n</code></pre> <p>The created migration will be placed into <code>myapp/migrations</code> and include a unix timestamp of when the migration was created. Since most IDEs will sort directories by integer value, you can look towards the bottom of your migrations directory to see the most recent migration that will be run.</p> <pre><code>from mountaineer.migrations.migrator import Migrator\nfrom mountaineer.migrations.migration import MigrationRevisionBase\nfrom mountaineer.migrations.dependency import MigrationDependencies\nfrom fastapi.param_functions import Depends\n\nclass MigrationRevision(MigrationRevisionBase):\n    up_revision: str = \"1715044020\"\n    down_revision: str | None = None\n\n    async def up(\n        self,\n        migrator: Migrator = Depends(MigrationDependencies.get_migrator),\n    ):\n        await migrator.actor.add_not_null(\n            table_name=\"article\",\n            column_name=\"author\"\n        )\n\n    async def down(\n        self,\n        migrator: Migrator = Depends(MigrationDependencies.get_migrator),\n    ):\n        await migrator.actor.drop_not_null(\n            table_name=\"article\",\n            column_name=\"author\"\n        )\n</code></pre> <p>Let's break down the migration file that was just generated:</p> <p>There's an <code>up</code> function that covers the migration to the new application state. These are standard dependency injection functions, so you can use any dependency injector in your application if you want to inject other variables. By default we just supply the migrator: Migrator which is a shallow wrapper that provides a database session (with an open connection) alongside an actor object that includes some common migration recipes.</p> <p>The <code>down</code> function does the inverse. It takes the database state after your migration has been run and downgrades it to the last version. It's useful to have this specified in case you need to rollback your migration to conform to the previously deployed service. This often requires some care at considering how you can safely rollback your migration, perhaps through keeping temporary columns around inbetween migrations that you know you might have to rollback.</p> <p>The <code>up_revision</code> and <code>down_revision</code> are used to track the migration state. The <code>up_revision</code> is the timestamp of the migration file, and the <code>down_revision</code> is the timestamp of the previous migration file. If you don't have a down revision, it will be set to <code>None</code>. These will be injected into a dynamic \"migration_info\" table in your database to track the current state of your migrations.</p>"},{"location":"database_migrations/#extending-migration-files","title":"Extending Migration Files","text":"<p>The <code>Migrator</code> object is a thin wrapper around the <code>DatabaseActions</code> object, which is a collection of common migration operations. If you need to perform a more complex migration operation, you can customize the logic by calling <code>migrator.actor</code> yourself. Head over to the DatabaseActions documentation to see the full list of available migration operations.</p> <p>In addition to the actor, you can also access the underlying database session object. This is useful if you need to run raw SQL queries that aren't covered by the actor object.</p> <pre><code>async def up(\n    self,\n    migrator: Migrator = Depends(MigrationDependencies.get_migrator),\n):\n    result = await migrator.db_session.exec(\"SELECT * FROM article\")\n</code></pre> <p>We recommend using the actor object whenever possible, as it provides a more consistent and safe way to run migrations. If you are using the raw database session object, be aware that we require migrations to be run in a single transaction. This ensures that if a migration fails, the database will be rolled back to its previous state. We therefore disable calling <code>db_session.commit()</code> explicitly from within user code.</p>"},{"location":"database_migrations/#alternatives","title":"Alternatives","text":"<p>While the Mountaineer core authors only support its native migration workflow, since the database primitives build off of SQLModel/SQLAlchemy there are other options in the ecosystem for migration generation.</p> <p>The industry standard migration package for SQLAlchemy is Alembic, which is a powerful and robust file-based migration library. A quick list of pros and our perceived cons:</p> <p>Pros:</p> <ul> <li>Mature project with a large user base and extensive documentation.</li> <li>It has a rich feature set, including support for multiple database backends and complex migration operations.</li> </ul> <p>Cons:</p> <ul> <li>Non-trivial setup complexity with configuration files and a separate CLI.</li> <li>In steady state it's sometimes unclear what migration responsibility Alembic owns, versus what should be delegated to SQLAlchemy.</li> </ul>"},{"location":"deploy/","title":"Deploy","text":"<p>You can deploy your Mountaineer project using whatever container technology you'd like, on whatever hosting provider you'd like. Most hosts at this point mandate or highly encourage containerization of your dependencies with Docker - so we start there.</p> <p>This page contains a reasonable default configuration to get you started. We make heavy use of multi-stage builds to cache dependencies and minimize the size of your final image that your webservers will have to pull down.</p>"},{"location":"deploy/#docker","title":"Docker","text":"<p>First, add the following to your <code>.dockerignore</code> file. This will prevent Docker from trying to copy over heavy artifacts that aren't needed for the build.</p> .dockerignore<pre><code>**/node_modules\n**/_server\n**/_ssr\n**/_static\n**/_metadata\n</code></pre>"},{"location":"deploy/#image-1-frontend-dependencies","title":"Image 1: Frontend Dependencies","text":"<p>Our first stage uses <code>npm</code> to fetch your frontend dependencies. This is an isolated context since it's the only place we need node / npm in the build pipeline.</p> <pre><code>FROM node:20-slim as node-dependencies\n\nWORKDIR /usr/src/app\n\n# We only require the dependency definitions\nCOPY {my_webapp}/views/package.json {my_webapp}/views/package-lock.json ./\nRUN npm install\n</code></pre>"},{"location":"deploy/#image-2-python-dependencies-base","title":"Image 2: Python Dependencies Base","text":"<p>Our build pipeline requires Poetry and a basic Python configuration in multiple stages. This initial stage sets up the Poetry CLI and a Python 3.11 environment. By default we make use of Docker's <code>buildx</code> to compile for linux/amd64 (Intel) since this is what most servers run on. It also lets us leverage our prebuild Mountaineer wheels.</p> <pre><code>FROM --platform=linux/amd64 python:3.11-slim as poetry-base\n\nWORKDIR /usr/src/app\n\n# You only need `nodejs` here if you are using the postcss plugin\nRUN apt-get update \\\n    &amp;&amp; apt-get install -y --no-install-recommends pipx nodejs\n\nENV PATH=\"/root/.local/bin:${PATH}\"\n\nRUN pipx install poetry\n</code></pre>"},{"location":"deploy/#image-3-python-dependencies","title":"Image 3: Python Dependencies","text":"<p>Fetch Python dependencies and package them into a virtualenv.</p> <pre><code>FROM poetry-base as venv-dependencies\n\nRUN pipx inject poetry poetry-plugin-bundle\n\n# Only copy package requirements to cache them in docker layer\n# We don't copy poetry.lock since this is tied to the specific architecture\n# of our dev machines\nCOPY pyproject.toml ./\n\n# Poetry requires a README.md to be present in the project\nCOPY README.md ./\n\n# Copy the application code\nCOPY {my_webapp} ./{my_webapp}\n\n# Gather dependencies and place into a new virtualenv\nRUN poetry -vvv bundle venv --python=/usr/local/bin/python --only=main /venv\n</code></pre>"},{"location":"deploy/#image-4-build-frontend-to-javascript","title":"Image 4: Build Frontend to Javascript","text":"<p>Static frontend plugins, provided by Mountaineer.</p> <pre><code>FROM poetry-base as server-hooks-builder\n\nCOPY pyproject.toml ./\nCOPY README.md ./\n\nCOPY {my_webapp} ./{my_webapp}\nCOPY --from=node-dependencies /usr/src/app/node_modules ./{my_webapp}/views/node_modules\n\n# Mount the application CLI handlers and build the artifacts\nRUN poetry install\nRUN poetry run build\n</code></pre>"},{"location":"deploy/#image-5-final-layer","title":"Image 5: Final Layer","text":"<p>Combines the raw python files, python dependencies, and the built frontend.</p> <pre><code>FROM --platform=linux/amd64 python:3.11-slim as final\n\n# Create and switch to a new user\nRUN useradd --create-home appuser\nUSER appuser\n\nENV PATH=\"/venv/bin:$PATH\"\n\nWORKDIR /usr/src/app\n\nCOPY --from=venv-dependencies /venv /venv\nCOPY --from=server-hooks-builder /usr/src/app/{my_webapp}/views /venv/lib/python3.11/site-packages/{my_webapp}/views\n\n# Run the application\nCMD [\"/venv/bin/uvicorn\", \"{my_webapp}.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"3000\"]\n</code></pre>"},{"location":"deploy/#local-testing","title":"Local Testing","text":"<p>Once your Docker image is built, the best way to test it is to run it locally with <code>docker run</code>. However you can also simulate what the production service is doing by running:</p> <pre><code>poetry run build\nENVIRONMENT=PRODUCTION poetry run uvicorn {my_webapp}.main:app --host localhost --port 5006\n</code></pre> <p>This runs with production-minified assets and the same configuration as the production server.</p>"},{"location":"deploy/#common-errors","title":"Common Errors","text":"<p>If you see \"required file not found\" when you try to run this docker image, double check that your venv is pointing to the correct version of Python within the container:</p> <pre><code>$ ls -ls /venv/bin\n\n4 -rw-r--r-- 1 root root 2209 Mar 29 00:26 activate\n4 -rw-r--r-- 1 root root 1476 Mar 29 00:26 activate.csh\n4 -rw-r--r-- 1 root root 3039 Mar 29 00:26 activate.fish\n4 -rw-r--r-- 1 root root 2724 Mar 29 00:26 activate.nu\n4 -rw-r--r-- 1 root root 1650 Mar 29 00:26 activate.ps1\n4 -rw-r--r-- 1 root root 1337 Mar 29 00:26 activate_this.py\n4 -rwxr-xr-x 1 root root  212 Mar 29 00:27 dotenv\n4 -rwxr-xr-x 1 root root  204 Mar 29 00:27 httpx\n0 lrwxrwxrwx 1 root root   25 Mar 29 00:26 python -&gt; /usr/local/bin/python3.11\n0 lrwxrwxrwx 1 root root    6 Mar 29 00:26 python3 -&gt; python\n0 lrwxrwxrwx 1 root root    6 Mar 29 00:26 python3.11 -&gt; python\n4 -rwxr-xr-x 1 root root  207 Mar 29 00:27 tqdm\n4 -rwxr-xr-x 1 root root  211 Mar 29 00:27 uvicorn\n4 -rwxr-xr-x 1 root root  211 Mar 29 00:27 watchfiles\n4 -rwxr-xr-x 1 root root  217 Mar 29 00:27 watchmedo\n</code></pre> <p>The path <code>python -&gt; /usr/local/bin/python3.11</code> should be executable and run the interpreter:</p> <pre><code>$ /venv/bin/python --version\n\nPython 3.11.8\n</code></pre>"},{"location":"error_handling/","title":"Error Handling","text":"<p>Errors are a fundamental part of computer science, but nowhere is that more evident than when building websites. There are so many factors you don't have control over: client latency, malformed payloads, spiky server load, resource contention for the same user. The list goes on. Any one can bring a user experience to its knees.</p> <p>All that to say - it's not a question of if you'll see errors but when. Mountaineer provides some handy utilities that make it a bit easier to handle the errors you may encounter in production.</p>"},{"location":"error_handling/#client-server-exceptions","title":"Client-&gt;Server exceptions","text":"<p>When client actions call server actions (either sideeffects or passthroughs), their browser needs to make an outgoing fetch request to your server. Your server can throw an error in response to this payload for any reason: validation failures, unexpected state, or just because some internal logic failed.</p> <p>When your server returns an error, your async action will raise the relevant error. Let's say you have the following component that issues an invalid call to a server action:</p> <pre><code>&lt;button\n  onClick={async () =&gt; {\n    await serverState.increment_count({\n      requestBody: {\n        // @ts-ignore\n        count: \"invalid payload\",\n      },\n    });\n  }}\n&gt;\n  Invalid Increment\n&lt;/button&gt;\n</code></pre> <p>When this button is clicked, it will send an <code>increment_count</code> action to the server. The server will validate the incoming payload with Pydantic, which will throw a ValidationError since it expects <code>count</code> to be an integer, not a string. The server will then respond with a 422 validation error, which will be passed back to the client and raised in the async function. You can catch this error with a try/catch block:</p> <pre><code>import { HTTPValidationErrorException } from \"./_server/actions\";\n\n...\n\n&lt;button\n  className=\"rounded-md bg-blue-500 p-2 text-white\"\n  onClick={async () =&gt; {\n    try {\n      await serverState.increment_count({\n        requestBody: {\n          // @ts-ignore\n          count: \"invalid payload\",\n        },\n      });\n    } catch (error) {\n      if (error instanceof HTTPValidationErrorException) {\n        console.log(\n          \"Validation Error\",\n          error.body.detail?.[0].loc,\n          error.body.detail?.[0].msg,\n        );\n      } else {\n        throw error;\n      }\n    }\n  }}\n&gt;\n  Invalid Increment\n&lt;/button&gt;\n</code></pre> <p>Mountaineer will convert the error into a custom error class and expose it in <code>_server/actions</code> for you to import. This class helps you switch logic depending on the type of error that was raised. Using a class here also has the benefit of typeguarding your error handling, so you'll see IDE recommendations specific to that ValidationError.</p> <p>You can find the error payload itself within <code>error.body</code>, which will be typehinted with all the metadata (if any) that the server is expected to return as part of this error code. In the above example, that looks like this:</p> <pre><code>Validation Error (2)\u00a0['body', 'count'] Input should be a valid integer, unable to parse string as an integer\n</code></pre> <p>Internally, we generate <code>HTTPValidationErrorException</code> as a subclass of FetchErrorBase. This provided the common error handling, while typehinting it for your specific API errors.</p> _server/actions.ts<pre><code>class HTTPValidationErrorException extends FetchErrorBase&lt;HTTPValidationError&gt; {}\n</code></pre> <p>Tip</p> <p>For more information on error typehinting and custom handling, see the FastAPI documentation.</p>"},{"location":"error_handling/#custom-errors","title":"Custom Errors","text":"<p>A 422 ValidationError is a special error that is included in every action, because your function signature is verified every time a client sends a new payload to your server. To implement a custom error that is specific to your application, you can subclass <code>APIException</code>:</p> <pre><code>from mountaineer.exceptions import APIException\n\nclass LoginInvalid(APIException):\n    status_code = 401\n    invalid_reason: str\n\nclass LoginController(ControllerBase):\n    ...\n\n    @passthrough(exception_models=[LoginInvalid])\n    def login(self, login_payload: LoginRequest):\n        raise LoginInvalid(invalid_reason=\"Login not implemented\")\n</code></pre> <p>Provide all the exceptions that your function may throw to <code>@passthrough(exception_models=[])</code>. The <code>@sideeffect</code> decorator accepts the same argument.</p> <p>When specified like this, Mountaineer turns your exception into a client-side exception just like <code>HTTPValidationErrorException</code>. You can now use it in the same way.</p>"},{"location":"error_handling/#ssr-timeouts","title":"SSR timeouts","text":"<p>To render each page on the server side, we have to execute your view's Javascript in a V8 engine. This is the same Javascript interpreter that powers Chrome. As such, you have the full freedom to write any Javascript in your view that will help you render your page - loops, calculations, package calls, etc.</p> <p>As is the case with Turing-complete languages, with great power comes great responsibility.</p> <p>These SSR requests can potentially take a long time. At the extreme, they could even clog up your server by infinite looping and never returning a value. We have a series of safeguards in place to help ensure SSR renders return quickly and keep your server able to chug through additional requests.</p> <ul> <li>Debug logging of the duration of each SSR page render, for use in development.</li> <li>Warning logs if rendering takes longer than some interval so you can keep an eye on endpoints that might need some optimization.</li> <li>Hard timeouts for rendering. If something goes sideways and your server rendering takes longer a maximum threshold, we'll terminate the server-side Javascript executor for you and return an error to the client.</li> </ul>"},{"location":"error_handling/#ssr-exceptions","title":"SSR exceptions","text":"<p>Alongside timeouts, it's possible your view's Javascript actually gets into an unrecoverable state and throws an exception during rendering. To help you debug this on the server side, we'll raise this error as a <code>mountaineer.ssr.V8RuntimeError</code> and log the stack trace that comes back from the V8 engine.</p> <p>The paths reported in the stack trace are found from the sourcemap that's created alongside the compiled SSR files. These should point to the files in your view directory that have produced that exception.</p> <pre><code>{\"level\": \"ERROR\", \"name\": \"mountaineer.logging\", \"message\": \"Exception encountered in ComplexController rendering\"}\nERROR:    Exception in ASGI application\nTraceback (most recent call last):\n  File \"/Users/piercefreeman/projects/mountaineer/mountaineer/ssr.py\", line 37, in render_ssr\n    render_result = mountaineer_rs.render_ssr(\n                    ^^^^^^^^^^^^^^^^^^^^\n...\n\n File \"/Users/piercefreeman/projects/mountaineer/mountaineer/ssr.py\", line 43, in render_ssr\n   raise V8RuntimeError(e)\nmountaineer.ssr.V8RuntimeError: Error calling function 'Index': Error: Example client error\nStack: Error: Example client error\n    at Page (./my_website/views/app/complex/page.tsx:41:10)\n    at renderWithHooks (./my_website/views/node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js:5660:15)\n    at renderIndeterminateComponent (./my_website/views/node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js:5733:14)\n    at renderElement (&lt;anonymous&gt;:6537:17)\n    at renderNodeDestructiveImpl (&lt;anonymous&gt;:6642:19)\n    at renderNodeDestructive (./my_website/views/node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js:6078:13)\n    at renderIndeterminateComponent (&lt;anonymous&gt;:6417:17)\n    at renderElement (&lt;anonymous&gt;:6537:17)\n    at renderNodeDestructiveImpl (&lt;anonymous&gt;:6642:19)\n    at renderNodeDestructive (./my_website/views/node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js:6078:13)\n</code></pre>"},{"location":"links/","title":"Links","text":"<p>In a typical webapp, you'll have a lot of links. Most will be internal to your site: detail pages, settings, profiles, etc. Traditionally, developers format these links manually and hope they don't break over time as routes update.</p> <p>In Mountaineer, generating links is baked into the client side routes. For every controller you define, we'll generate a link interface that defines the parameters that controller accepts. This interface will update as your route declarations do, so you're guaranteed to always generate the latest links to successfully resolve that controller.</p> <p>Controllers set the parameters that they need to render their views by configuring the <code>render()</code> function with the required parameters:</p> <pre><code>class DetailController:\n    url = \"/detail/{detail_id}\"\n\n    def render(self, detail_id: int, checking_out: bool = False) -&gt; MyDetailData:\n        ...\n</code></pre> <p>Alongside generating the appropriate API and router files, Mountaineer will detect this render signature and produce a link generator.</p> <p>This particular generator will require a <code>detail_id</code> and support an optional <code>checking_out</code> boolean. The <code>detail_id</code> is required because it's a part of the controller url. <code>checking_out</code> on the other hand is optional, since it has a default keyword argument in the case that another value isn't provided.</p> <p>On the client side, you can now create these dynamic links anywhere within your application. Mount the server state of the current view and use the included <code>linkGenerator</code>.</p> <pre><code>const MyHomeRoute = () =&gt; {\n  const serverState = useServer();\n\n  return (\n    &lt;a\n      href={serverState.linkGenerator.detailController({\n        detail_id: \"9280ca4d-e607-486a-a343-7bbaae6b5a86\",\n      })}\n    &gt;\n      Detail Link\n    &lt;/a&gt;\n  )\n}\n</code></pre> <p>Not providing the <code>detail_id</code>, or providing an incorrect type for the ID, will throw a typescript error at compile time.</p>"},{"location":"links/#link-parameters","title":"Link Parameters","text":"<p>There are two types of dynamic URL parameters:</p> <ul> <li>Path Variables: <code>/product/[product_id]</code></li> <li>Query Variables: <code>/posts?page=[page_num]</code></li> </ul> <p>Both path variables and query variables are exposed as interface definitions within the link generator.</p>"},{"location":"metadata/","title":"Page Metadata","text":"<p>Pages will have metadata associated with them: page title, description, tags, stylesheets, etc. Mountaineer specifies this metadata in the Python layer, during the initial render.</p> <p>Each <code>RenderBase</code> schema implements a <code>metadata</code> attribute. This metadata lets you customize the different fields that are injected in your html  tag: <pre><code>class Metadata(BaseModel):\n    title: str | None = None\n    metas: list[MetaAttribute] = []\n    links: list[LinkAttribute] = []\n</code></pre>"},{"location":"metadata/#title","title":"Title","text":"<p>Setting a page title is pretty straightforward. You just return a custom Metadata instance within your <code>render()</code> function. Because the metadata logic is located in-scope of your other business logic, you can access the full suit of calculated values. This is helpful to conditionally generate a dynamic title - like injecting a user's account name, number of new messages, etc.</p> <pre><code>class MyRender(RenderBase):\n    pass\n\ndef render() -&gt; MyRender:\n    return MyRender(\n        metadata=Metadata(\n            title=\"My Title\"\n        )\n    )\n</code></pre>"},{"location":"metadata/#meta-and-links","title":"Meta and Links","text":"<p>We provide a pretty vanilla syntax within <code>Metadata</code> so you can specify any  and  elements you'd liek. We do this with the recognition that only some meta tag values have been standardized, and others are left to the browser implementations or web crawlers to parse them appropriately.</p> <p>You'll typically instantiate a  tag like this:</p> <pre><code>class MyRender(RenderBase):\n    pass\n\ndef render() -&gt; MyRender:\n    return MyRender(\n        metadata=Metadata(\n            metas=MetaAttribute(\n                \"og:meta\",\n                content=\"Some meta content\",\n            )\n        )\n    )\n</code></pre> <p>We have a limited number of helper  constructors, particularly in cases where there are standard definitions of complex meta values. For more details on the supported Metadata and rendering options, check out the API Docs.</p>"},{"location":"metadata/#global-metadata","title":"Global Metadata","text":"<p>For metadata that you know should appear on every page (like stylesheets or global scripts), you can add a metadata tag to your app controller:</p> <pre><code>controller = AppController(\n    global_metadata=Metadata(\n        links=[LinkAttribute(rel=\"stylesheet\", href=\"/static/main.css\")]\n    ),\n)\n</code></pre>"},{"location":"postcss/","title":"PostCSS &amp; Tailwind","text":""},{"location":"postcss/#postcss","title":"PostCSS","text":"<p>PostCSS is a compiler for CSS. It enables buildtime transformation of CSS files to convert SCSS, LESS, or other CSS-like languages into standard CSS. It also has utilities for polyfills and browser-specific prefixes. I think of it like a swiss-army knife for CSS: it helps assure that your styling intentions are actually rendered uniformily across browsers.</p> <p>PostCSS support is handled as a buildtime plugin with Mountaineer. It's disabled by default. To enable, make sure you have <code>postcss-cli</code> installed within your <code>views</code> project:</p> <pre><code>npm install postcss-cli\n</code></pre> <p>After this you can leverage the <code>PostCSSBundler</code> within your custom build pipeline:</p> <pre><code>from mountaineer.client_compiler.postcss import PostCSSBundler\n\ncontroller = AppController(\n    custom_builders=[\n        PostCSSBundler(),\n    ],\n)\n</code></pre> <p>Adding the PostCSSBundler will find all the <code>.css</code> that you have specified within your <code>views</code> directory and pass them through PostCSS. Let's say you have the following CSS files:</p> <pre><code>/views/app/home/style.css\n/views/app/detail/style.css\n</code></pre> <p>The compiler will\u00a0pass each through PostCSS and deposit these artifacts into:</p> <pre><code>/views/_static/home_style.css\n/views/_static/detail_style.css\n</code></pre> <p>You can then import this CSS file in whatever  tag is relevant to your project. See the metadata documentation for more details on how to do this.</p>"},{"location":"postcss/#tailwind","title":"Tailwind","text":"<p>Tailwind uses PostCSS to handle the tree shaking and project analysis that allows it to output the minimal amount of CSS tags to correctly render your project. If you set up the PostCSS extension like described above, you should be able to follow the typical Tailwind setup steps.</p> views/app/tailwind.config.ts<pre><code>module.exports = {\n  content: [\"./app/**/*.{html,tsx,jsx,ts,js}\"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n</code></pre> views/app/main.css<pre><code>@tailwind base;\n@tailwind components;\n@tailwind utilities;\n</code></pre> <p>Then export the built styles into your global metadata:</p> <pre><code>controller = AppController(\n    config=AppConfig(),\n    global_metadata=Metadata(\n        links=[LinkAttribute(rel=\"stylesheet\", href=\"/static/app_main.css\")]\n    ),\n    custom_builders=[\n        PostCSSBundler(),\n    ],\n)\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Our quickstart guide walks you through creating a full Mountaineer project. The end application is simple but fully working and ready for deployment.</p>"},{"location":"quickstart/#getting-started","title":"Getting Started","text":"<p>To get started as quickly as possible, we bundle a project generator that sets up a simple project after a quick Q&amp;A. Make sure you have pipx installed.</p> <pre><code>$ pipx run create-mountaineer-app\n\n? Project name [my-project]: my_webapp\n? Author [Pierce Freeman &lt;pierce@freeman.vc&gt;] Default\n? Use poetry for dependency management? [Yes] Yes\n? Create stub MVC files? [Yes] Yes\n? Use Tailwind CSS? [Yes] Yes\n? Add editor configuration? [vscode] vscode\n</code></pre> <p>Mountaineer projects all follow a similar structure. For more on this, see our deep dive on the structure conventions.</p>"},{"location":"quickstart/#development","title":"Development","text":"<p>If you're starting a new application from scratch, you'll typically want to create your new database tables. Make sure you have postgres running. We bundle a docker compose file for convenience with <code>create-mountaineer-app</code>.</p> <pre><code>docker compose up -d\npoetry run createdb\n</code></pre> <p>Of course you can also use an existing database instance, simply configure it in the <code>.env</code> file in the project root.</p> <p>Mountaineer relies on watching your project for changes and doing progressive compilation. We provide a few CLI commands to help with this.</p> <p>While doing development work, you'll usually want to preview the frontend and automatically build dependent files. You can do this with:</p> <pre><code>$ poetry run runserver\n\nINFO:     Started server process [93111]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://127.0.0.1:5006 (Press CTRL+C to quit)\n</code></pre> <p>Navigate to http://127.0.0.1:5006 to see your new webapp running.</p> <p>Or, if you just want to watch the source tree for changes without hosting the server. Watching will allow your frontend to pick up API definitions from your backend controllers:</p> <pre><code>$ poetry run watch\n</code></pre> <p>Both of these CLI commands are specified in your project's <code>cli.py</code> file.</p>"},{"location":"quickstart/#walkthrough","title":"Walkthrough","text":"<p>Below we go through some of the unique aspects of Mountaineer. Let's create a simple Todo list where we can add new items.</p> <p>For the purposes of this walkthrough we assume your project is generated with <code>create-mountaineer-app</code> and you've skipped MVC stub files. If not, you'll have to delete some of the pre-existing files.</p> <p>Let's get started by creating the data models that will persist app state to the database. These definitions are effectively Pydantic schemas that will be bridged to the database via SQLModel.</p> my_webapp/models/todo.py<pre><code>from mountaineer.database import SQLModel, Field\nfrom uuid import UUID, uuid4\n\nclass TodoItem(SQLModel, table=True):\n    id: UUID = Field(default_factory=uuid4, primary_key=True)\n\n    description: str\n    completed: bool = False\n</code></pre> <p>Update the index file as well:</p> my_webapp/models/__init__.py<pre><code>from .todo import TodoItem # noqa: F401\n</code></pre> <p>Make sure you have a Postgres database running. We bundle a docker compose file for convenience with <code>create-mountaineer-app</code>. Launch it in the background and create the new database tables from these code definitions:</p> <pre><code>docker compose up -d\npoetry run createdb\npoetry run runserver\n</code></pre> <p>Great! At this point we have our database tables created and have a basic server running. We next move to creating a new controller, since this will define which data you can push and pull to your frontend.</p> my_webapp/controllers/home.py<pre><code>from mountaineer import sideeffect, ControllerBase, RenderBase\nfrom mountaineer.database import DatabaseDependencies\n\nfrom fastapi import Request, Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlmodel import select\n\nfrom my_webapp.models.todo import TodoItem\n\nclass HomeRender(RenderBase):\n    client_ip: str\n    todos: list[TodoItem]\n\nclass HomeController(ControllerBase):\n    url = \"/\"\n    view_path = \"/app/home/page.tsx\"\n\n    async def render(\n        self,\n        request: Request,\n        session: AsyncSession = Depends(DatabaseDependencies.get_db_session)\n    ) -&gt; HomeRender:\n        todos = (await session.exec(select(TodoItem))).all()\n\n        return HomeRender(\n            client_ip=(\n                request.client.host\n                if request.client\n                else \"unknown\"\n            ),\n            todos=todos\n        )\n</code></pre> <p>The only three requirements of a controller are setting the:</p> <ul> <li>URL</li> <li>View path</li> <li>Initial data payload</li> </ul> <p>This <code>render()</code> function is a core building block of Mountaineer. All Controllers need to have one. It defines all the data that your frontend will need to resolve its view. This particular controller retrieves all Todo items from the database, alongside the user's current IP.</p> <p>Tip</p> <p>render() functions accepts all parameters that FastAPI endpoints do: paths, query parameters, and dependency injected functions. Right now we're just grabbing the <code>Request</code> object to get the client IP.</p> <p>Note that the database session is provided via dependency injection, which plug-and-plays with FastAPI's Depends syntax. The standard library provides two main dependency providers:</p> <ul> <li>mountaineer.CoreDependencies: helper functions for configurations and general dependency injection</li> <li>mountaineer.database.DatabaseDependencies: helper functions for database lifecycle and management</li> </ul> <p>Now that we've newly created this controller, we wire it up to the application. This registers it for display when you load the homepage.</p> my_webapp/app.py<pre><code>from mountaineer.app import AppController\nfrom mountaineer.client_compiler.postcss import PostCSSBundler\nfrom mountaineer.render import LinkAttribute, Metadata\n\nfrom my_webapp.config import AppConfig\nfrom my_webapp.controllers.home import HomeController\n\ncontroller = AppController(\n    config=AppConfig(),\n    global_metadata=Metadata(\n        links=[LinkAttribute(rel=\"stylesheet\", href=\"/static/app_main.css\")]\n    ),\n    custom_builders=[\n        PostCSSBundler(),\n    ],\n)\n\ncontroller.register(HomeController())\n</code></pre> <p>Let's move over to the frontend.</p> my_webapp/views/app/home/page.tsx<pre><code>import React from \"react\";\nimport { useServer, ServerState } from \"./_server/useServer\";\n\nconst CreateTodo = ({ serverState }: { serverState: ServerState }) =&gt; {\n  return (\n    &lt;div className=\"flex gap-x-4\"&gt;\n      &lt;input\n        type=\"text\"\n        className=\"grow rounded border-2 border-gray-200 px-4 py-2\"\n      /&gt;\n      &lt;button className=\"rounded bg-blue-500 px-4 py-2 font-bold text-white hover:bg-blue-700\"&gt;\n        Create\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\nconst Home = () =&gt; {\n  const serverState = useServer();\n\n  return (\n    &lt;div className=\"mx-auto max-w-2xl space-y-8 p-8 text-2xl\"&gt;\n      &lt;p&gt;\n        Hello {serverState.client_ip}, you have {serverState.todos.length} todo\n        items.\n      &lt;/p&gt;\n      &lt;CreateTodo serverState={serverState} /&gt;\n      {\n        /* Todo items are exposed as typehinted Typescript interfaces */\n        serverState.todos.map((todo) =&gt; (\n          &lt;div key={todo.id} className=\"rounded border-2 border-gray-200 p-4\"&gt;\n            &lt;div&gt;{todo.description}&lt;/div&gt;\n          &lt;/div&gt;\n        ))\n      }\n    &lt;/div&gt;\n  );\n};\n\nexport default Home;\n</code></pre> <p>We define a simple view to show the data coming from the backend. To accomplish this conventionally, we'd need to wire up an API layer, a Node server, or format the page with Jinja templates.</p> <p>Here instead we use our automatically generated <code>useServer()</code> hook. This hook payload will provide all the <code>HomeRender</code> fields as properties of serverState. And it's available instantly on page load without any roundtrip fetches. Also - if your IDE supports language servers (which most do these days), you should see the fields auto-suggesting for <code>serverState</code> as you type.</p> <p></p> <p>If you access this in your browser at <code>localhost:5006/</code> we can see our welcome message, but we can't really do anything with the todos yet. Let's add some interactivity.</p> <p>Tip</p> <p>Try disabling Javascript in your browser. The page will still render as-is with all variables intact, thanks to our server-side rendering.</p> <p></p> <p>What good is todo list that doesn't get longer? We define a <code>add_todo</code> function that accepts a pydantic model <code>NewTodoRequest</code>, which defines the required parameters for a new todo item. We then cast this to a database object and add it to the postgres table.</p> my_webapp/controllers/home.py<pre><code>from pydantic import BaseModel\n\nclass NewTodoRequest(BaseModel):\n    description: str\n\nclass HomeController(ControllerBase):\n    ...\n\n    @sideeffect\n    async def add_todo(\n        self,\n        payload: NewTodoRequest,\n        session: AsyncSession = Depends(DatabaseDependencies.get_db_session)\n    ) -&gt; None:\n        new_todo =  TodoItem(description=payload.description)\n        session.add(new_todo)\n        await session.commit()\n</code></pre> <p>The important part here is the <code>@sideeffect</code>. Once you create a new Todo item, the previous state on the frontend is outdated. It will only show the todos before you created a new one. That's not what we want in an interactive app. This decorator indicates that we want the frontend to refresh its data, since after we update the todo list on the server the client state will be newly outdated.</p> <p>Mountaineer detects the presence of this sideeffect function and analyzes its signature. It then exposes this to the frontend as a normal async function.</p> my_webapp/views/app/home/page.tsx<pre><code>import React, { useState } from \"react\";\nimport { useServer } from \"./_server/useServer\";\n\n/* Replace the existing CreateTodo component definition you have */\nconst CreateTodo = ({ serverState }: { serverState: ServerState }) =&gt; {\n  const [newTodo, setNewTodo] = useState(\"\");\n\n  return (\n    &lt;div className=\"flex gap-x-4\"&gt;\n      &lt;input\n        type=\"text\"\n        className=\"grow rounded border-2 border-gray-200 px-4 py-2\"\n        value={newTodo}\n        onChange={(e) =&gt; setNewTodo(e.target.value)}\n      /&gt;\n      &lt;button\n        className=\"rounded bg-blue-500 px-4 py-2 font-bold text-white hover:bg-blue-700\"\n        onClick={\n          /* Here we call our sideeffect function */\n          async () =&gt; {\n            await serverState.add_todo({\n              requestBody: {\n                description: newTodo,\n              },\n            });\n            setNewTodo(\"\");\n          }\n        }\n      &gt;\n        Create\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n\n...\n\nexport default Home;\n</code></pre> <p><code>useServer()</code> exposes our <code>add_todo</code> function so we can call our backend directly from our frontend. Also notice that we don't have to read or parse the output value of this function to render the new todo item to the list. Since the function is marked as a sideeffect, the frontend will automatically refresh its data after the function is called.</p> <p>Go ahead and load it in your browser. If you open up your web tools, you can create a new Todo and see POST requests sending data to the backend and receiving the current server state. The actual data updates and merging happens internally by Mountaineer.</p> <p></p> <p></p> <p>You can use these serverState variables anywhere you'd use dynamic React state variables (useEffect, useCallback, etc). But unlike React state, these variables are automatically updated when a relevant sideeffect is triggered.</p> <p>And that's it. We've just built a fully interactive web application without having to worry about an explicit API. You specify the data model and actions on the server and the appropriate frontend hooks are generated and updated automatically. It gives you the power of server rendered html and the interactivity of a virtual DOM, without having to compromise on complicated data mutations to keep everything in sync.</p>"},{"location":"static_analysis/","title":"Static Analysis","text":"<p>A core design consideration in Mountaineer is allowing for full static analysis of your webapps. This term just means that we can verify your code from its text alone without having to run it all. As your webapp grows in scope this becomes increasingly valuable, as it allows you to catch errors early before they become runtime issues. And the more complicated your logic becomes, the more switch conditions and edge cases you're necessarily going to have. Manually testing all that is... not going to be fun.</p> <p>Since static analysis is a personal choice, we don't yet bundle a type checker within Mountaineer. This page covers some basic suggestions for adding it to your project.</p> <p>Tip</p> <p>Adding a type checker to your project might seem like overkill while the scope is still small. But we find that adding it to CI early helps prevent future headaches by taking small steps to correctly annotate your function signatures, resolve ambiguities, and catch bugs while you still have the context of implementation.</p>"},{"location":"static_analysis/#python","title":"Python","text":"<p><code>mypy</code> and <code>pyright</code> are the most popular type checkers for Python. They both effectively do the same thing. <code>mypy</code> is a bit more mature and has a larger community, but <code>pyright</code> is often preferred by IDEs so you help ensure your dev workflow is the same as your CI verification. We typically use both in our projects to be extra safe.</p> <pre><code>poetry add mypy --group dev\npoetry add pyright --group dev\n</code></pre> <p>Then modify your <code>pyproject.toml</code> to make as strict as you would like. Here's a good starting point for mypy:</p> <pre><code>[tool.mypy]\nwarn_return_any = true\nwarn_unused_configs = true\ncheck_untyped_defs = true\nplugins = [\"pydantic.mypy\"]\n</code></pre> <p>Pyright is already a bit stricter by default, but you can really boost the verbosity by specifying:</p> <pre><code>[tool.pyright]\ntypeCheckingMode = \"strict\"\n</code></pre> <p>Then, to run against your project:</p> <pre><code>poetry run mypy\npoetry run pyright\n</code></pre>"},{"location":"static_analysis/#typescript","title":"Typescript","text":"<p>Typescript's main goal as a language extension to Javascript is to provide typechecking and static analysis. These features are built into the default compiler <code>tsc</code>. As such, most frontend issues in your Mountaineer project are typically caught when we compile your typescript code with <code>poetry run build</code> or progressively with <code>runserver</code> or <code>watch</code>. However there are some cases where you don't want to perform a full build, like in CI where you just want to validate the current state of your project.</p> <pre><code>npm install typescript --save-dev\n</code></pre> <p>The <code>tsconfig.json</code> specifies the level of strictness you want to enforce. These options set to the strictest level will catch the most errors:</p> views/tsconfig.json<pre><code>{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"strictBindCallApply\": true,\n    \"strictPropertyInitialization\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true\n  }\n}\n</code></pre> Parameter Description strict Enables all strict type-checking options. Setting this to true is the easiest way to ensure you're using TypeScript's strictest settings. noImplicitAny Raises error on expressions and declarations with an implied any type. strictNullChecks When enabled, null and undefined are not in the domain of every type. strictFunctionTypes Ensures functions' parameters are correctly typed. strictBindCallApply Enforce stricter checking of the bind, call, and apply methods on functions. strictPropertyInitialization Ensures class properties are initialized in the constructor. noImplicitReturns Report error when not all code paths in function return a value. noFallthroughCasesInSwitch Prevent fall-through cases in switch statements. <p>Then, to run against your project:</p> views/package.json<pre><code>{\n  \"scripts\": {\n    \"typecheck\": \"tsc --noEmit\"\n  }\n}\n</code></pre> <pre><code>npm run typecheck\n</code></pre>"},{"location":"structure/","title":"Structure","text":"<p>Mountaineer projects all follow a similar structure. This structure is provided by default through <code>create-mountaineer-app</code> but you can also construct it yourself.</p> <p>For a project called <code>my_webapp</code>, you should have something like the following:</p> <pre><code>my_webapp/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 docker compose.yml\n\u251c\u2500\u2500 my_webapp\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 app.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 cli.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 controllers\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 detail.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 home.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 main.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 models\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 detail.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 views\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 app\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 node_modules\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 package-lock.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 package.json\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 postcss.config.js\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 tailwind.config.js\n\u251c\u2500\u2500 poetry.lock\n\u2514\u2500\u2500 pyproject.toml\n</code></pre> <p>Every service file is nested under the <code>my_webapp</code> root package. This is just a regular python project - you add new code files wherever you like and import them as you're used to.</p>"},{"location":"structure/#mandatory-conventions","title":"Mandatory Conventions","text":"<p><code>views</code> - this disk based directory includes a nested npm project. Within it you write all your frontend logics and components, which are regular typescript/tsx files.</p> <p>Nested routes are in nested folders. This folder acts as your React project and is where you can define requirements and build parameters in <code>package.json</code> and <code>tsconfig.json</code>.</p>"},{"location":"structure/#suggested-conventions","title":"Suggested Conventions","text":"<p><code>controllers</code> - A controller is the python logic that backs your frontend view. You can define controllers however you like: a flat folder, nesting folders, or via no folders at all mixed in with other code. For simplicity we recommend starting with a single flat controllers folder and refactoring into sub-folders as distinct ownership areas of your code emerge.</p> <p><code>app.py</code> - Instantiate your controllers and add them to an <code>AppController</code> to register them for client access.</p> <p><code>config.py</code> - Specify the parameters that your application needs to run, to easily customize them: database host settings, secret keys, etc. Configurations can easily read from env variables and are globally accessible throughout your webapp.</p> <p><code>main.py</code> - Expose your application to uvicorn or another async compatible webserver that follows the ASGI specification (Asynchronous Server Gateway Interface).</p>"},{"location":"views/","title":"Views &amp; Layouts","text":"<p>Your React app should be initialized in the <code>/views</code> folder of your Mountaineer project. This is the directory where we look for package.json and tsconfig.json, and where esbuild looks for specific build-time overrides. In other words, the views folder should look just like your frontend application if you were building a Single-Page-App (SPA). It's just embedded within your larger Mountaineer project and rendered separately.</p> <p>We expect that all controller views will be labeled as a <code>page.tsx</code>, so they'll typically sit in a folder with themselves and other tightly connected React components. These views should have one default export, which is your page constructor:</p> /views/app/home/page.tsx<pre><code>import React from \"react\";\n\nconst Home = () =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Home&lt;/h1&gt;\n      &lt;p&gt;Welcome to the home page!&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default Home;\n</code></pre> <p>We don't support async functions for these page renders, instead expecting that your backend will provide all data required to serialize the view.</p> <p>If you want actions performed on the client-side after the view has been hydrated with Javascript, you can use a <code>useEffect</code> hook with an empty dependency list:</p> /views/app/home/page.tsx<pre><code>import React, { useEffect } from \"react\";\n\nconst Home = () =&gt; {\n  useEffect(() =&gt; {\n    console.log(\"The page has been hydrated with Javascript!\");\n  }, []);\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Home&lt;/h1&gt;\n      &lt;p&gt;Welcome to the home page!&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default Home;\n</code></pre>"},{"location":"views/#controllers","title":"Controllers","text":"<p>A controller backs a view in a 1:1 relationship. It provides the backend plumbing to render the view, and can also provide sideeffects and passthroughs actions. The main entrypoint into this is the <code>render</code> function, which is called on your initial view to serialize all the data that your frontend will need when displaying the initial state of the page. All your data heavy lifting (database queries, manipulation, etc) should go here.</p> /controllers/home.py<pre><code>from mountaineer import sideeffect, ControllerBase, RenderBase\nfrom mountaineer.database import DatabaseDependencies\nfrom mountaineer.database.session import AsyncSession\n\nfrom sqlmodel import select\n\nfrom myapp.models import TodoItem\n\nclass HomeRender(RenderBase):\n    todos: list[TodoItem]\n\nclass HomeController(ControllerBase):\n    url = \"/\"\n    view_path = \"/app/home/page.tsx\"\n\n    async def render(\n        self,\n        session: AsyncSession = Depends(DatabaseDependencies.get_db_session)\n    ) -&gt; HomeRender:\n        todos = (await session.execute(select(TodoItem))).all()\n\n        return HomeRender(\n            todos=todos\n        )\n</code></pre>"},{"location":"views/#path-parameters","title":"Path Parameters","text":"<p>The <code>render</code> function signature is inspected to provide the full URL that can be called. To provide a URL parameter that extracts a given ID identifier and matches the following:</p> <pre><code>/details/a687566b-db3e-42e3-9053-4f679abe8277\n/details/4a4c26bc-554a-40dd-aecd-916abd3bc475\n</code></pre> <p>You can do:</p> <pre><code>class DetailController(ControllerBase):\n    url = \"/details/{item_id}\"\n    view_path = \"/app/details/page.tsx\"\n\n    async def render(\n        self,\n        item_id: UUID,\n    ) -&gt; HomeRender:\n        ...\n</code></pre>"},{"location":"views/#query-parameters","title":"Query Parameters","text":"<p>Query parameters are also supported. We support both simple types (str, float, UUID, etc) alongside lists of simple types. To provide a query parameter that matches the following:</p> <pre><code>/search?name=Apple&amp;cost=30&amp;cost=50\n/search?name=Banana\n</code></pre> <p>You can do:</p> <pre><code>from typing import Annotated\nfrom fastapi import Query\n\nclass SearchController(ControllerBase):\n    url = \"/search\"\n    view_path = \"/app/search/page.tsx\"\n\n    async def render(\n        self,\n        name: str,\n        cost: Annotated[list[int] | None, Query()] = None,\n    ) -&gt; HomeRender:\n        ...\n</code></pre> <p>Tip</p> <p>Both path and query parameters are validated by FastAPI, so you can use the same validation techniques. For more details, see the FastAPI guide.</p>"},{"location":"views/#layouts","title":"Layouts","text":"<p>We also support the Next.js <code>layout.tsx</code> convention, which is a special file that will be used to wrap all containing views in a common layout. This is useful for things like headers, footers, and other common elements.</p> <p>The children of the page will be passed as <code>{children}</code> to the layout component. Make sure to include this in your rendered view:</p> /views/app/layout.tsx<pre><code>import React from \"react\";\n\nconst Layout = ({ children } : { children: React.ReactNode }) =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;header&gt;\n        &lt;h1&gt;My Website&lt;/h1&gt;\n      &lt;/header&gt;\n      &lt;main&gt;\n        {children}\n      &lt;/main&gt;\n      &lt;footer&gt;\n        &lt;p&gt;\u00a9 My Website&lt;/p&gt;\n      &lt;/footer&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default Layout;\n</code></pre> <p>This allows you to chain layouts before rendering the final, most specific page:</p> <pre><code>views/\n\u2514\u2500\u2500 app/\n    \u251c\u2500\u2500 dashboard/\n    \u2502   \u251c\u2500\u2500 layout.tsx\n    \u2502   \u251c\u2500\u2500 home/\n    \u2502   \u2502   \u2514\u2500\u2500 page.tsx\n    \u2502   \u2514\u2500\u2500 settings/\n    \u2502       \u2514\u2500\u2500 page.tsx\n    \u2514\u2500\u2500 layout.tsx\n</code></pre> <p>When rendering <code>dashboard/home/page.tsx</code>, the view will be wrapped in the <code>app/dashboard/layout.tsx</code> layout alongside <code>app/layout.tsx</code>. These layout files will be automatically found by Mountaineer during the build process. They don't require any explicit declaration in your Python backend if you're just using them for styling.</p> <p>If you need more server side power and want to define them in Python, you can add a LayoutController that backs the layout.</p>"},{"location":"views/#layout-controllers","title":"Layout Controllers","text":"<p>Layouts support most of the same controller logic that regular pages do. They can specify their own actions, both sideeffects and passthroughs, which will re-render the layout as required.</p> /controllers/root_layout.py<pre><code>from mountaineer import LayoutControllerBase, RenderBase\nfrom mountaineer.actions import sideeffect\n\nclass RootLayoutRender(RenderBase):\n    layout_value: int\n\nclass RootLayoutController(LayoutControllerBase):\n    view_path = \"/app/layout.tsx\"\n\n    def __init__(self):\n        super().__init__()\n        self.layout_value = 0\n\n    def render(self) -&gt; RootLayoutRender:\n        return RootLayoutRender(\n            layout_value=self.layout_value,\n        )\n\n    @sideeffect\n    async def increment_layout_value(self) -&gt; None:\n        self.layout_value += 1\n</code></pre> <p>All these functions are now exposed to the frontend layout, including the link generator, state, and any actions specified.</p> /views/app/layout.tsx<pre><code>import React, { ReactNode } from \"react\";\nimport { useServer } from \"./_server\";\n\nconst Layout = ({ children }: { children: ReactNode }) =&gt; {\n  const serverState = useServer();\n\n  return (\n    &lt;div className=\"p-6\"&gt;\n      &lt;h1&gt;Layout State: {serverState.layout_value}&lt;/h1&gt;\n      &lt;div&gt;{children}&lt;/div&gt;\n      &lt;div&gt;\n        &lt;button\n          className=\"rounded-md bg-indigo-500 p-2 text-white\"\n          onClick={async () =&gt; {\n            await serverState.increment_layout_value();\n          }}\n        &gt;\n          Increase Ticker\n        &lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default Layout;\n</code></pre> <p>Once your controller is declared, you'll need to mount your layout into the AppController like you do for regular pages.</p> /app.py<pre><code>app_controller = AppController(...)\napp_controller.register(RootLayoutController())\n</code></pre> <p>In general you can implement layout controllers just like you do for pages. But since they're shared across multiple child controllers, make sure the keyword arguments you use in your <code>render</code> signature don't have any conflicts. Mountaineer will merge these signatures at runtime and check for duplicate keyword names across the layout's child pages. Arguments are allowed to share the same name and type, in which case they will be resolved to the same value. Arguments with conflicting types will raise a <code>TypeError</code>.</p> <p>It's also worth noting that layout controllers will resolve their dependencies in the same scope as the page controllers. So if you need database access within your layout, you'll receive the same underlying transaction as the page controller. This makes dependency injection a powerful way to save on resources, but be careful to not treat them as isolated objects.</p>"},{"location":"views/#typescript-configuration","title":"Typescript Configuration","text":"<p>If you want to customize how Mountaineer builds your view files into raw client-side javascript, add a <code>tsconfig.json</code> file. The Typescript website includes a full list of the available options here. A good place to start is:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"es2017\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\",\n    \"incremental\": true,\n  },\n  \"exclude\": [\"node_modules\"]\n}\n</code></pre> <p>A common convention is importing all your view paths with absolute paths (like <code>@/components/myfile</code>) instead of having to do relative imports (<code>../../components/myfile</code>). This can be easily achieved by adding a <code>paths</code> key to your <code>tsconfig.json</code>. Your import becomes relative to all paths in the root directory.</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"es2017\",\n    ...\n    \"paths\": {\n      \"@/*\": [\"./*\"]\n    }\n  },\n  \"exclude\": [\"node_modules\"]\n}\n</code></pre>"},{"location":"api/actions/","title":"Actions","text":""},{"location":"api/actions/#mountaineer.actions.passthrough_dec.passthrough","title":"mountaineer.actions.passthrough_dec.passthrough","text":"<pre><code>passthrough(*args, **kwargs)\n</code></pre> <p>Only functions that are explicitly marked as actions will be accessable by the frontend. The @passthrough decorator indicates that this function should be called by the frontend and will return an explicit data payload. It will NOT update the render() state of the frontend.</p> <p>Decorate functions within your ControllerBase that you want to expose. Each of these functions should specify a return type. Normal passthrough endpoints can return with either a <code>None</code>, a <code>BaseModel</code> object, or a <code>JSONResponse</code> if you need full flexibility on return headers and content structure.</p> <p>If you do return a JSONResponse note that we will handle the merging of the response for you - so on the client side you will still access your endpoint contents with:</p> <pre><code>const response = await serverState.my_action({});\nconsole.log(response.passthrough);\n</code></pre> <p>Usage:</p> <pre><code>from pydantic import BaseModel\n\nclass ResponseModel(BaseModel):\n    pass\n\nclass MyController(ControllerBase):\n    @passthrough\n    async def my_action(self) -&gt; ResponseModel:\n        ...\n</code></pre> PARAMETER DESCRIPTION <code>exception_models</code> <p>List of APIException subclasses that this function is known to throw. These will be parsed and available to frontend clients.</p> <p> TYPE: <code>list[Type[APIException]] | None</code> </p> <code>raw_response</code> <p>If specified, you can return a generic fastapi.Response object. There's no constraint this endpoint returns JSON - you can return html or a custom protocol. This lets you treat this API as a generic POST endpoint for you to fully control the output.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>BaseModel | None | fastapi.JSONResponse</code> <p>The response model to use for this endpoint. If a BaseModel is not provided (you pass a dictionary or a SQLModel object ofr instance), we will try to convert the response object into the proper JSON response based on your typehint.</p>"},{"location":"api/actions/#mountaineer.actions.sideeffect_dec.sideeffect","title":"mountaineer.actions.sideeffect_dec.sideeffect","text":"<pre><code>sideeffect(*args, **kwargs)\n</code></pre> <p>Mark a function as causing a sideeffect to the data. This will force a reload of the full (or partial) server state and sync these changes down to the client page.</p> <p>Like passthroughs, @sideeffect accepts return values of None, BaseModel, or a JSONResponse if you need full flexibility on return headers and content structure. Unlike @passthrough, it does not allow you to provide a non-JSON response since we need to internally merge it with render() sideeffect update.</p> PARAMETER DESCRIPTION <code>exception_models</code> <p>List of APIException subclasses that this function is known to throw. These will be parsed and available to frontend clients.</p> <p> TYPE: <code>list[Type[APIException]] | None</code> </p> <code>reload</code> <p>If provided, will ONLY reload these fields on the client side. By default will reload all fields. Otherwise, why specify a sideeffect at all? Note that even if this is provided, we will still regenerate a fully full state on the server as if render() is called again. This parameter only controls the data that is streamed back to the client in order to help reduce bandwidth of data that won't be changed.</p> <p> TYPE: <code>tuple[FieldClassDefinition, ...] | None</code> </p> <code>experimental_render_reload</code> <p>Experimental options. Disabled by default.  If True, will attempt to only execute the logic in render() that is required to calculate your <code>reload</code> parameters. Other logic will be short-circuited. If your render function has significant computation for other properties this can be a significant performance improvement. However, it is experimental and may not work in all cases.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>BaseModel | None | fastapi.JSONResponse</code> <p>The response model to use for this endpoint. If a BaseModel is not provided (you pass a dictionary or a SQLModel object ofr instance), we will try to convert the response object into the proper JSON response based on your typehint.</p>"},{"location":"api/api_exception/","title":"API Exception","text":"<p>The <code>APIException</code> is the root exception that you should inherit for errors that are thrown within action functions. This syntax allows your frontend to pick up on the error parameters. APIExceptions are just Pydantic BaseModels with a few helpful defaults, and a metaclass that allows them to work natively with HTTPExceptions.</p>"},{"location":"api/api_exception/#mountaineer.exceptions.APIException","title":"mountaineer.exceptions.APIException","text":"<pre><code>APIException(**kwargs)\n</code></pre> <p>               Bases: <code>HTTPException</code></p> <p>Base class for user defined APIExceptions that can be thrown in server actions and should provide some metadata back to the client caller.</p> <pre><code>class PostNotFound(APIException):\n    status_code: int = 404\n    detail: str = \"The post was not found\"\n    post_id: int\n    is_deleted: bool\n\nclass MyController(ControllerBase):\n    @passthrough\n    def get_post(self, post_id: int) -&gt; Post:\n        post = self.post_service.get_post(post_id)\n        if not post:\n            raise PostNotFound(post_id=post_id, is_deleted=True)\n        return post\n</code></pre>"},{"location":"api/api_exception/#mountaineer.exceptions.APIException.status_code","title":"status_code  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>status_code = 500\n</code></pre>"},{"location":"api/api_exception/#mountaineer.exceptions.APIException.detail","title":"detail  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>detail = 'A server error occurred'\n</code></pre>"},{"location":"api/app-controller/","title":"App Controller","text":""},{"location":"api/app-controller/#mountaineer.app.AppController","title":"mountaineer.app.AppController","text":"<pre><code>AppController(\n    *,\n    name=\"Mountaineer Webapp\",\n    version=\"0.1.0\",\n    view_root=None,\n    global_metadata=None,\n    custom_builders=None,\n    config=None,\n    fastapi_args=None\n)\n</code></pre> <p>Main entrypoint of a project web application.</p> PARAMETER DESCRIPTION <code>global_metadata</code> <p>Script and meta will be applied to every page rendered by this application. Title will only be applied if the page does not already have a title set.</p> <p> TYPE: <code>Metadata | None</code> DEFAULT: <code>None</code> </p> <code>config</code> <p>Application global configuration.</p> <p> TYPE: <code>ConfigBase | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/app-controller/#mountaineer.app.AppController.register","title":"register","text":"<pre><code>register(controller)\n</code></pre> <p>Register a new controller. This will:</p> <ul> <li>Mount the html of the controller to the main application service</li> <li>Mount all actions (ie. @sideeffect and @passthrough decorated functions) to their public API</li> </ul> PARAMETER DESCRIPTION <code>controller</code> <p>The controller instance that should be added to your webapp. The class accepts a full instance instead of just a class, so you're able to perform any kind of runtime initialization of the kwarg args that you need before it's registered.</p> <p> TYPE: <code>ControllerBase</code> </p>"},{"location":"api/cli/","title":"CLI Plugins","text":"<p>CLI Plugins provide default handling for the most common lifecycle events during Mountaineer development. Import these if convenient, otherwise you can follow our implementation approaches to implement your own.</p>"},{"location":"api/cli/#webapp-cli","title":"Webapp CLI","text":"<p>Building your app will compile your TypeScript into the client-side bundle that will be downloaded by the browser. It also ahead-of-time generates the server code that will be run as part of SSR. You'll want to do it before deploying your application into production - but since a full build can take up to 10s, <code>handle_runserver</code> provides a better workflow for daily development.</p>"},{"location":"api/cli/#mountaineer.cli.handle_runserver","title":"mountaineer.cli.handle_runserver","text":"<pre><code>handle_runserver(\n    *,\n    package,\n    webservice,\n    webcontroller,\n    host=\"127.0.0.1\",\n    port,\n    subscribe_to_mountaineer=False\n)\n</code></pre> <p>Start a local development server. This will hot-reload your browser any time your frontend or backend code changes.</p> PARAMETER DESCRIPTION <code>package</code> <p>Ex. \"ci_webapp\"</p> <p> TYPE: <code>str</code> </p> <code>webservice</code> <p>Ex. \"ci_webapp.app:app\"</p> <p> TYPE: <code>str</code> </p> <code>webcontroller</code> <p>Ex. \"ci_webapp.app:controller\"</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>Desired port for the webapp while running locally</p> <p> TYPE: <code>int</code> </p> <code>subscribe_to_mountaineer</code> <p>See <code>handle_watch</code> for more details.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/cli/#mountaineer.cli.handle_watch","title":"mountaineer.cli.handle_watch","text":"<pre><code>handle_watch(\n    *,\n    package,\n    webcontroller,\n    subscribe_to_mountaineer=False\n)\n</code></pre> <p>Watch the file directory and rebuild auto-generated files. This only creates the frontend files necessary to get server-side typehints. It doesn't build the package for production use.</p> PARAMETER DESCRIPTION <code>package</code> <p>Ex. \"ci_webapp\"</p> <p> TYPE: <code>str</code> </p> <code>webcontroller</code> <p>Ex. \"ci_webapp.app:controller\"</p> <p> TYPE: <code>str</code> </p> <code>subscribe_to_mountaineer</code> <p>If True, will subscribe the local build server to changes in the <code>mountaineer</code> package. This is useful when doing concurrent development in <code>mountaineer</code> and a client package. Rarely used otherwise.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/cli/#mountaineer.cli.handle_build","title":"mountaineer.cli.handle_build","text":"<pre><code>handle_build(*, webcontroller, minify=True)\n</code></pre> <p>Creates a production bundle of frontend files that is ready for service.</p> <p>Building your app will compile your TypeScript into the client-side bundle that will be downloaded by the browser. It also ahead-of-time generates the server code that will be run as part of SSR. You'll want to do it before deploying your application into production - but since a full build can take up to 10s, <code>handle_runserver</code> provides a better workflow for daily development.</p> PARAMETER DESCRIPTION <code>webcontroller</code> <p>Ex. \"ci_webapp.app:controller\"</p> <p> TYPE: <code>str</code> </p> <code>minify</code> <p>Minify the JS bundle, strip debug symbols</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"api/cli/#database-cli","title":"Database CLI","text":""},{"location":"api/cli/#mountaineer.database.cli.handle_createdb","title":"mountaineer.database.cli.handle_createdb  <code>async</code>","text":"<pre><code>handle_createdb(*args, **kwargs)\n</code></pre> <p>Strictly speaking, passing a list of models isn't required for this function. We'll happily accept being called with <code>handle_createdb()</code>. We just encourage an explicit passing of either the models module or the SQLModels themselves to make sure they are in-scope of the table registry when this function is run. This is how we determine which tables to create at runtime.</p> PARAMETER DESCRIPTION <code>model_module</code> <p>The module containing the SQLModels to create</p> <p> </p> <code>models</code> <p>An explicit list of SQLModels to create</p> <p> </p>"},{"location":"api/config/","title":"Config","text":""},{"location":"api/config/#application-config","title":"Application Config","text":""},{"location":"api/config/#mountaineer.config.ConfigBase","title":"mountaineer.config.ConfigBase","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Base class for the running application's configuration. By convention all configuration parameters should be specified here in one payload. You'll often call your subclass <code>ConfigBase</code>.</p> <p>Users are responsible for instantiating an AppConfig with your desired settings. This instance will be registered into the global space so it's accessible to your controllers. An error will be thrown if you attempt to instantiate more than one AppConfig.</p>"},{"location":"api/config/#mountaineer.config.ConfigBase.PACKAGE","title":"PACKAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PACKAGE = None\n</code></pre>"},{"location":"api/config/#mountaineer.config.ConfigBase.ENVIRONMENT","title":"ENVIRONMENT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ENVIRONMENT = 'development'\n</code></pre>"},{"location":"api/config/#mountaineer.config.ConfigBase.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'frozen': True}\n</code></pre>"},{"location":"api/config/#mountaineer.config.get_config","title":"mountaineer.config.get_config","text":"<pre><code>get_config()\n</code></pre>"},{"location":"api/config/#internal-functions","title":"Internal Functions","text":"<p>Used in unit testing or some other scenarios where you need specific control over the configuration that is mounted into the global registry.</p>"},{"location":"api/config/#mountaineer.config.register_config","title":"mountaineer.config.register_config","text":"<pre><code>register_config(config)\n</code></pre>"},{"location":"api/config/#mountaineer.config.unregister_config","title":"mountaineer.config.unregister_config","text":"<pre><code>unregister_config()\n</code></pre>"},{"location":"api/config/#mountaineer.config.get_config","title":"mountaineer.config.get_config","text":"<pre><code>get_config()\n</code></pre>"},{"location":"api/controller/","title":"View Controller","text":""},{"location":"api/controller/#mountaineer.controller.ControllerBase","title":"mountaineer.controller.ControllerBase","text":"<pre><code>ControllerBase(\n    slow_ssr_threshold=0.1, hard_ssr_timeout=10.0\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[RenderInput]</code></p> <p>One Controller should be created for every frontend page in your webapp. Clients can override this <code>__init__</code> function so long as they call <code>super().__init__()</code> at the start of their init to setup the internal handlers.</p> PARAMETER DESCRIPTION <code>slow_ssr_threshold</code> <p>Each python process has a single V8 runtime associated with it, so SSR rendering can become a bottleneck if it requires processing. We log a warning if we detect that an SSR render took longer than this threshold.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>hard_ssr_timeout</code> <p>If the SSR render takes longer than this threshold, we will automatically kill the V8 runtime and return an error to the client. This is useful for avoiding blocking the reset of the server process if the React render\u00a0logic hangs.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>10.0</code> </p>"},{"location":"api/controller/#mountaineer.controller.ControllerBase.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url\n</code></pre>"},{"location":"api/controller/#mountaineer.controller.ControllerBase.view_path","title":"view_path  <code>instance-attribute</code>","text":"<pre><code>view_path\n</code></pre>"},{"location":"api/controller/#mountaineer.controller.ControllerBase.definition","title":"definition  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>definition = None\n</code></pre>"},{"location":"api/controller/#mountaineer.controller.ControllerBase.bundled_scripts","title":"bundled_scripts  <code>instance-attribute</code>","text":"<pre><code>bundled_scripts = []\n</code></pre>"},{"location":"api/controller/#mountaineer.controller.ControllerBase.initialized","title":"initialized  <code>instance-attribute</code>","text":"<pre><code>initialized = True\n</code></pre>"},{"location":"api/controller/#mountaineer.controller.ControllerBase.slow_ssr_threshold","title":"slow_ssr_threshold  <code>instance-attribute</code>","text":"<pre><code>slow_ssr_threshold = slow_ssr_threshold\n</code></pre>"},{"location":"api/controller/#mountaineer.controller.ControllerBase.hard_ssr_timeout","title":"hard_ssr_timeout  <code>instance-attribute</code>","text":"<pre><code>hard_ssr_timeout = hard_ssr_timeout\n</code></pre>"},{"location":"api/controller/#mountaineer.controller.ControllerBase.source_map","title":"source_map  <code>instance-attribute</code>","text":"<pre><code>source_map = None\n</code></pre>"},{"location":"api/controller/#mountaineer.controller.ControllerBase.view_base_path","title":"view_base_path  <code>instance-attribute</code>","text":"<pre><code>view_base_path = None\n</code></pre>"},{"location":"api/controller/#mountaineer.controller.ControllerBase.ssr_path","title":"ssr_path  <code>instance-attribute</code>","text":"<pre><code>ssr_path = None\n</code></pre>"},{"location":"api/controller/#mountaineer.controller.ControllerBase.script_name","title":"script_name  <code>property</code>","text":"<pre><code>script_name\n</code></pre>"},{"location":"api/controller/#mountaineer.controller.ControllerBase.render","title":"render  <code>abstractmethod</code>","text":"<pre><code>render(*args, **kwargs)\n</code></pre> <p>Render provides the raw data payload that will be sent to the frontend on initial render and during any sideeffect update. In most cases, you should return a RenderBase instance. If you have no data to display you can also return None.</p> <p>This function must be explicitly typehinted with your response type, which allows the AppController to generate the correct TypeScript types for the frontend:</p> <pre><code>class MyServerData(RenderBase):\n    pass\n\nclass MyController:\n    def render(self) -&gt; MyServerData:\n        pass\n</code></pre> <p>If you don't intend to sync any data from server-&gt;client you can typehint this function with an explicit None return annotation:</p> <pre><code>class MyController:\n    def render(self) -&gt; None:\n        pass\n</code></pre> <p>Render functions accept any number of arguments and keyword arguments, following the FastAPI route parameter style. This includes query parameters, path parameters, and request bodies.</p> <pre><code>class MyController:\n    url = \"/my-url/{path_param}\"\n\n    def render(\n        self,\n        query_param: str,\n        path_param: int,\n        dependency: MyDependency = Depends(MyDependency),\n    ) -&gt; MyServerData:\n        ...\n</code></pre> RETURNS DESCRIPTION <code>RenderBase | None | Coroutine[Any, Any, RenderBase | None]</code> <p>A RenderBase instance or None</p>"},{"location":"api/controller/#mountaineer.controller.ControllerBase.resolve_paths","title":"resolve_paths","text":"<pre><code>resolve_paths(view_base=None, force=True)\n</code></pre> <p>Typically used internally by the Mountaineer build pipeline. Calling this function sets the active <code>view_base</code> of the frontend project, which allows us to resolve the built javascripts that are required for this controller.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether we have found all necessary files and fully updated the controller state.</p>"},{"location":"api/controller/#layout-controller","title":"Layout Controller","text":""},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase","title":"mountaineer.controller_layout.LayoutControllerBase","text":"<pre><code>LayoutControllerBase(\n    slow_ssr_threshold=0.1, hard_ssr_timeout=10.0\n)\n</code></pre> <p>               Bases: <code>ControllerBase</code></p> <p>Base class for layouts. Layout controllers are used to generate the HTML that wrap a regular view controller. They support all actions that a regular controller does (@sideeffect and @passthrough).</p> <p>Their limitations: - They are run in an isolated dependency injection context, they don't share     dependency injected values with the given page - The current page Request is not supported within render() - Sideeffect updates to the layout don't affect the page state, and vice-versa - Layout controllers can't be mounted as a URL route</p> <p>One Controller should be created for every frontend page in your webapp. Clients can override this <code>__init__</code> function so long as they call <code>super().__init__()</code> at the start of their init to setup the internal handlers.</p> PARAMETER DESCRIPTION <code>slow_ssr_threshold</code> <p>Each python process has a single V8 runtime associated with it, so SSR rendering can become a bottleneck if it requires processing. We log a warning if we detect that an SSR render took longer than this threshold.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>hard_ssr_timeout</code> <p>If the SSR render takes longer than this threshold, we will automatically kill the V8 runtime and return an error to the client. This is useful for avoiding blocking the reset of the server process if the React render\u00a0logic hangs.</p> <p> TYPE: <code>float | None</code> DEFAULT: <code>10.0</code> </p>"},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url\n</code></pre>"},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase.view_path","title":"view_path  <code>instance-attribute</code>","text":"<pre><code>view_path\n</code></pre>"},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase.bundled_scripts","title":"bundled_scripts  <code>instance-attribute</code>","text":"<pre><code>bundled_scripts = []\n</code></pre>"},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase.definition","title":"definition  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>definition = None\n</code></pre>"},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase.initialized","title":"initialized  <code>instance-attribute</code>","text":"<pre><code>initialized = True\n</code></pre>"},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase.slow_ssr_threshold","title":"slow_ssr_threshold  <code>instance-attribute</code>","text":"<pre><code>slow_ssr_threshold = slow_ssr_threshold\n</code></pre>"},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase.hard_ssr_timeout","title":"hard_ssr_timeout  <code>instance-attribute</code>","text":"<pre><code>hard_ssr_timeout = hard_ssr_timeout\n</code></pre>"},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase.source_map","title":"source_map  <code>instance-attribute</code>","text":"<pre><code>source_map = None\n</code></pre>"},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase.view_base_path","title":"view_base_path  <code>instance-attribute</code>","text":"<pre><code>view_base_path = None\n</code></pre>"},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase.ssr_path","title":"ssr_path  <code>instance-attribute</code>","text":"<pre><code>ssr_path = None\n</code></pre>"},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase.script_name","title":"script_name  <code>property</code>","text":"<pre><code>script_name\n</code></pre>"},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase.render","title":"render  <code>abstractmethod</code>","text":"<pre><code>render(*args, **kwargs)\n</code></pre> <p>Render provides the raw data payload that will be sent to the frontend on initial render and during any sideeffect update. In most cases, you should return a RenderBase instance. If you have no data to display you can also return None.</p> <p>This function must be explicitly typehinted with your response type, which allows the AppController to generate the correct TypeScript types for the frontend:</p> <pre><code>class MyServerData(RenderBase):\n    pass\n\nclass MyController:\n    def render(self) -&gt; MyServerData:\n        pass\n</code></pre> <p>If you don't intend to sync any data from server-&gt;client you can typehint this function with an explicit None return annotation:</p> <pre><code>class MyController:\n    def render(self) -&gt; None:\n        pass\n</code></pre> <p>Render functions accept any number of arguments and keyword arguments, following the FastAPI route parameter style. This includes query parameters, path parameters, and request bodies.</p> <pre><code>class MyController:\n    url = \"/my-url/{path_param}\"\n\n    def render(\n        self,\n        query_param: str,\n        path_param: int,\n        dependency: MyDependency = Depends(MyDependency),\n    ) -&gt; MyServerData:\n        ...\n</code></pre> RETURNS DESCRIPTION <code>RenderBase | None | Coroutine[Any, Any, RenderBase | None]</code> <p>A RenderBase instance or None</p>"},{"location":"api/controller/#mountaineer.controller_layout.LayoutControllerBase.resolve_paths","title":"resolve_paths","text":"<pre><code>resolve_paths(view_base=None, force=True)\n</code></pre> <p>Typically used internally by the Mountaineer build pipeline. Calling this function sets the active <code>view_base</code> of the frontend project, which allows us to resolve the built javascripts that are required for this controller.</p> RETURNS DESCRIPTION <code>bool</code> <p>Whether we have found all necessary files and fully updated the controller state.</p>"},{"location":"api/core_dependencies/","title":"Core Dependencies","text":""},{"location":"api/core_dependencies/#mountaineer.dependencies.CoreDependencies","title":"mountaineer.dependencies.CoreDependencies","text":"<p>Core dependencies for Mountaineer projects.</p>"},{"location":"api/logging/","title":"Logging","text":""},{"location":"api/logging/#mountaineer.logging.setup_logger","title":"mountaineer.logging.setup_logger","text":"<pre><code>setup_logger(name, log_level=logging.DEBUG)\n</code></pre> <p>Constructor for the main logger used by Mountaineer. Provided convenient defaults for log level and formatting, alongside coloring of stdout/stderr messages and JSON fields for structured parsing.</p>"},{"location":"api/logging/#mountaineer.logging.log_time_duration","title":"mountaineer.logging.log_time_duration","text":"<pre><code>log_time_duration(message)\n</code></pre> <p>Context manager to time a code block at runtime.</p> <pre><code>with log_time_duration(\"Long computation\"):\n    # Simulate work\n    sleep(10)\n</code></pre>"},{"location":"api/render/","title":"Render","text":""},{"location":"api/render/#mountaineer.render.RenderBase","title":"mountaineer.render.RenderBase","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for all renderable data models. Subclass this model when defining your own component data schema.</p>"},{"location":"api/render/#mountaineer.render.RenderBase.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata = Field(default=None, exclude=True)\n</code></pre>"},{"location":"api/render/#mountaineer.render.RenderBase.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'frozen': True}\n</code></pre>"},{"location":"api/render/#mountaineer.render.Metadata","title":"mountaineer.render.Metadata","text":"<p>               Bases: <code>BaseModel</code></p> <p>Metadata lets the client specify the different metadata definitions that should appear on the current page. These are outside the scope of React management so are only handled once on the initial page render.</p>"},{"location":"api/render/#mountaineer.render.Metadata.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title = None\n</code></pre>"},{"location":"api/render/#mountaineer.render.Metadata.metas","title":"metas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metas = []\n</code></pre>"},{"location":"api/render/#mountaineer.render.Metadata.links","title":"links  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>links = []\n</code></pre>"},{"location":"api/render/#mountaineer.render.Metadata.scripts","title":"scripts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>scripts = []\n</code></pre>"},{"location":"api/render/#mountaineer.render.Metadata.explicit_response","title":"explicit_response  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>explicit_response = None\n</code></pre>"},{"location":"api/render/#mountaineer.render.Metadata.ignore_global_metadata","title":"ignore_global_metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_global_metadata = False\n</code></pre>"},{"location":"api/render/#mountaineer.render.Metadata.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {\n    \"extra\": \"forbid\",\n    \"arbitrary_types_allowed\": True,\n}\n</code></pre>"},{"location":"api/render/#mountaineer.render.Metadata.merge","title":"merge","text":"<pre><code>merge(parent)\n</code></pre>"},{"location":"api/render/#mountaineer.render.Metadata.build_header","title":"build_header","text":"<pre><code>build_header()\n</code></pre> <p>Builds the header for this controller. Returns the list of tags that will be injected into the  tag of the rendered page."},{"location":"api/render/#headers-scripts","title":"Headers: Scripts","text":""},{"location":"api/render/#mountaineer.render.ScriptAttribute","title":"mountaineer.render.ScriptAttribute","text":"<p>               Bases: <code>HashableAttribute</code>, <code>BaseModel</code></p>"},{"location":"api/render/#mountaineer.render.ScriptAttribute.src","title":"src  <code>instance-attribute</code>","text":"<pre><code>src\n</code></pre>"},{"location":"api/render/#mountaineer.render.ScriptAttribute.asynchronous","title":"asynchronous  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>asynchronous = False\n</code></pre>"},{"location":"api/render/#mountaineer.render.ScriptAttribute.defer","title":"defer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defer = False\n</code></pre>"},{"location":"api/render/#mountaineer.render.ScriptAttribute.optional_attributes","title":"optional_attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>optional_attributes = {}\n</code></pre>"},{"location":"api/render/#mountaineer.render.ScriptAttribute.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre>"},{"location":"api/render/#headers-links","title":"Headers: Links","text":""},{"location":"api/render/#mountaineer.render.LinkAttribute","title":"mountaineer.render.LinkAttribute","text":"<p>               Bases: <code>HashableAttribute</code>, <code>BaseModel</code></p>"},{"location":"api/render/#mountaineer.render.LinkAttribute.rel","title":"rel  <code>instance-attribute</code>","text":"<pre><code>rel\n</code></pre>"},{"location":"api/render/#mountaineer.render.LinkAttribute.href","title":"href  <code>instance-attribute</code>","text":"<pre><code>href\n</code></pre>"},{"location":"api/render/#mountaineer.render.LinkAttribute.optional_attributes","title":"optional_attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>optional_attributes = {}\n</code></pre>"},{"location":"api/render/#mountaineer.render.LinkAttribute.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre>"},{"location":"api/render/#headers-metas","title":"Headers: Metas","text":"<p>We provide support for all <code>&lt;meta&gt;</code> arguments via the <code>MetaAttribute</code> class. We also provide some convenient shortcuts more more complicated, common meta tags.</p>"},{"location":"api/render/#mountaineer.render.MetaAttribute","title":"mountaineer.render.MetaAttribute","text":"<p>               Bases: <code>HashableAttribute</code>, <code>BaseModel</code></p>"},{"location":"api/render/#mountaineer.render.MetaAttribute.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = None\n</code></pre>"},{"location":"api/render/#mountaineer.render.MetaAttribute.content","title":"content  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content = None\n</code></pre>"},{"location":"api/render/#mountaineer.render.MetaAttribute.optional_attributes","title":"optional_attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>optional_attributes = {}\n</code></pre>"},{"location":"api/render/#mountaineer.render.MetaAttribute.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre>"},{"location":"api/render/#mountaineer.render.ViewportMeta","title":"mountaineer.render.ViewportMeta","text":"<p>               Bases: <code>MetaAttribute</code></p> <p>Defines the bounds on the current page and how much users are able to zoom.</p> <pre><code>ViewportMeta(\n    initial_scale=1.0,\n    maximum_scale=2.0,\n    user_scalable=True,\n)\n</code></pre>"},{"location":"api/render/#mountaineer.render.ViewportMeta.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = None\n</code></pre>"},{"location":"api/render/#mountaineer.render.ViewportMeta.content","title":"content  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content = None\n</code></pre>"},{"location":"api/render/#mountaineer.render.ViewportMeta.optional_attributes","title":"optional_attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>optional_attributes = {}\n</code></pre>"},{"location":"api/render/#mountaineer.render.ViewportMeta.width","title":"width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width = 'device-width'\n</code></pre>"},{"location":"api/render/#mountaineer.render.ViewportMeta.initial_scale","title":"initial_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial_scale = 1.0\n</code></pre>"},{"location":"api/render/#mountaineer.render.ViewportMeta.maximum_scale","title":"maximum_scale  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>maximum_scale = 1.0\n</code></pre>"},{"location":"api/render/#mountaineer.render.ViewportMeta.user_scalable","title":"user_scalable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_scalable = False\n</code></pre>"},{"location":"api/render/#mountaineer.render.ViewportMeta.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre>"},{"location":"api/render/#mountaineer.render.ViewportMeta.create_attribute","title":"create_attribute","text":"<pre><code>create_attribute()\n</code></pre>"},{"location":"api/render/#mountaineer.render.ThemeColorMeta","title":"mountaineer.render.ThemeColorMeta","text":"<p>               Bases: <code>MetaAttribute</code></p> <p>Customizes the default color that is attached to the page.</p> <pre><code>ThemeColorMeta(\n    color=\"white\",\n    media=\"light\",\n)\n</code></pre>"},{"location":"api/render/#mountaineer.render.ThemeColorMeta.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = None\n</code></pre>"},{"location":"api/render/#mountaineer.render.ThemeColorMeta.content","title":"content  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content = None\n</code></pre>"},{"location":"api/render/#mountaineer.render.ThemeColorMeta.optional_attributes","title":"optional_attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>optional_attributes = {}\n</code></pre>"},{"location":"api/render/#mountaineer.render.ThemeColorMeta.color","title":"color  <code>instance-attribute</code>","text":"<pre><code>color\n</code></pre>"},{"location":"api/render/#mountaineer.render.ThemeColorMeta.media","title":"media  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>media = None\n</code></pre>"},{"location":"api/render/#mountaineer.render.ThemeColorMeta.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre>"},{"location":"api/render/#mountaineer.render.ThemeColorMeta.create_attribute","title":"create_attribute","text":"<pre><code>create_attribute()\n</code></pre>"},{"location":"api/ssr/","title":"SSR","text":"<p>Most SSR logic is handled in our embedded Rust layer. In Rust we spin up a V8 isolate, handle logging, catch and process exceptions, etc. This page only covers the client functions that are exposed to Python.</p>"},{"location":"api/ssr/#ssr_1","title":"SSR","text":""},{"location":"api/ssr/#mountaineer.ssr.render_ssr","title":"mountaineer.ssr.render_ssr","text":"<pre><code>render_ssr(script, render_data, hard_timeout=None)\n</code></pre> <p>Render the React component in the provided SSR javascript bundle. This file will be directly executed within the V8 runtime.</p> <p>To speed up requests for the same exact content (ie. same react and same data) we cache the result of the render_ssr_rust call by default for a limited amount of previous calls. We limit the overall size of this cache to 5MB.</p> PARAMETER DESCRIPTION <code>script</code> <p>The raw code of the javascript bundle to execute. Should be pre-compiled into an SSR compatible package with a single entrypoint.</p> <p> TYPE: <code>str</code> </p> <code>render_data</code> <p>The data to inject into the SSR javascript bundle</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>hard_timeout</code> <p>The maximum time to allow the render to take in seconds. If the render takes longer than this time, our thread supervisor will kick in and terminate the rust worker.</p> <p> TYPE: <code>int | float | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>TimeoutError</code> <p>If the render takes longer than the hard_timeout</p> <code>V8RuntimeError</code> <p>If the V8 runtime throws an exception during the render</p>"},{"location":"api/ssr/#mountaineer.ssr.V8RuntimeError","title":"mountaineer.ssr.V8RuntimeError","text":"<p>               Bases: <code>Exception</code></p> <p>An exception thrown by the V8 runtime in the case of a permanent failure that involves the content of the script.</p>"},{"location":"api/ssr/#source-maps","title":"Source Maps","text":""},{"location":"api/ssr/#mountaineer.client_compiler.source_maps.SourceMapParser","title":"mountaineer.client_compiler.source_maps.SourceMapParser","text":"<pre><code>SourceMapParser(path)\n</code></pre> <p>Parse sourcemaps according to the official specification: https://sourcemaps.info/spec.html</p> PARAMETER DESCRIPTION <code>relative_to</code> <p>If specified, will output source paths relative to this path.</p> <p> </p>"},{"location":"api/ssr/#mountaineer.client_compiler.source_maps.SourceMapParser.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path = Path(path)\n</code></pre>"},{"location":"api/ssr/#mountaineer.client_compiler.source_maps.SourceMapParser.source_map","title":"source_map  <code>instance-attribute</code>","text":"<pre><code>source_map = None\n</code></pre>"},{"location":"api/ssr/#mountaineer.client_compiler.source_maps.SourceMapParser.parsed_mappings","title":"parsed_mappings  <code>instance-attribute</code>","text":"<pre><code>parsed_mappings = None\n</code></pre>"},{"location":"api/ssr/#mountaineer.client_compiler.source_maps.SourceMapParser.parse","title":"parse","text":"<pre><code>parse()\n</code></pre> <p>Parse the source map file and build up the internal mappings. This is deterministic with respect to the initialized source map path, so this will be a no-op if it's already been run.</p>"},{"location":"api/ssr/#mountaineer.client_compiler.source_maps.SourceMapParser.get_original_location","title":"get_original_location","text":"<pre><code>get_original_location(line, column)\n</code></pre> <p>For a compiled line and column, return the original line and column where they appeared in the pre-built file.</p> PARAMETER DESCRIPTION <code>line</code> <p>The line number in the compiled file</p> <p> TYPE: <code>int</code> </p> <code>column</code> <p>The column number in the compiled file</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/ssr/#mountaineer.client_compiler.source_maps.SourceMapParser.map_exception","title":"map_exception","text":"<pre><code>map_exception(exception)\n</code></pre> <p>Given a JS stack exception, try to map it to the original files and line numbers</p> PARAMETER DESCRIPTION <code>exception</code> <p>The exception string to map</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The exception string with the original file and line numbers. Note that some exception stack traces may not be mappable, and will be left as-is.</p>"},{"location":"api/ssr/#mountaineer.client_compiler.source_maps.SourceMapParser.convert_relative_path","title":"convert_relative_path","text":"<pre><code>convert_relative_path(absolute_path)\n</code></pre> <p>Absolute paths are convenient for internal use since they fully qualify a given file. However, for display they often get long and repetitive across multiple lines. This function will convert an absolute path to a relative path if it's within the same directory as the current working directory.</p> PARAMETER DESCRIPTION <code>absolute_path</code> <p>The absolute path to convert</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <p>The relative path if it's within the current working directory, otherwise the unmodified absolute path.</p>"},{"location":"api/watch_server/","title":"Watch server","text":""},{"location":"api/watch_server/#watch-server","title":"Watch Server","text":"<p>Used by Mountaineer CLI hooks to isolate your server and push updates to live-reload browsers. You probably won't have to deal with this class explicitly.</p>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager","title":"mountaineer.app_manager.HotReloadManager","text":"<pre><code>HotReloadManager(\n    package,\n    module,\n    module_name,\n    controller_name,\n    app_controller,\n    host,\n    port,\n    live_reload_port,\n)\n</code></pre> <p>Manages the lifecycle of a single app controller, including its webservice thread and utilities for hot-reloading.</p> <p>This is only intended for development use.</p>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.package","title":"package  <code>instance-attribute</code>","text":"<pre><code>package = package\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.module","title":"module  <code>instance-attribute</code>","text":"<pre><code>module = module\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.module_name","title":"module_name  <code>instance-attribute</code>","text":"<pre><code>module_name = module_name\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.controller_name","title":"controller_name  <code>instance-attribute</code>","text":"<pre><code>controller_name = controller_name\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.app_controller","title":"app_controller  <code>instance-attribute</code>","text":"<pre><code>app_controller = app_controller\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.webservice_thread","title":"webservice_thread  <code>instance-attribute</code>","text":"<pre><code>webservice_thread = None\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.host","title":"host  <code>instance-attribute</code>","text":"<pre><code>host = host\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port = port\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.live_reload_port","title":"live_reload_port  <code>instance-attribute</code>","text":"<pre><code>live_reload_port = live_reload_port\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.exception_controller","title":"exception_controller  <code>instance-attribute</code>","text":"<pre><code>exception_controller = ExceptionController()\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.from_webcontroller","title":"from_webcontroller  <code>classmethod</code>","text":"<pre><code>from_webcontroller(\n    webcontroller,\n    host=None,\n    port=None,\n    live_reload_port=None,\n)\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.update_module","title":"update_module","text":"<pre><code>update_module()\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.restart_server","title":"restart_server","text":"<pre><code>restart_server()\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.objects_in_module","title":"objects_in_module","text":"<pre><code>objects_in_module(module)\n</code></pre> <p>Given a module like <code>myapp.controllers.my_controller</code> it will find all the objects that are actually defined in that file (versus imported into that file but with a root definition elsewhere).</p>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.package_path_to_module","title":"package_path_to_module","text":"<pre><code>package_path_to_module(file_path_raw)\n</code></pre> <p>We are notified about changes to files on disk, this function converts the filename to Python's addressable module syntax.</p>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.module_to_package_path","title":"module_to_package_path","text":"<pre><code>module_to_package_path(module_name)\n</code></pre> <p>Converts a Python module name to its corresponding file path on disk. Returns a Path object.</p>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.get_submodules_with_objects","title":"get_submodules_with_objects","text":"<pre><code>get_submodules_with_objects(root_module, object_ids)\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.get_modified_subclass_modules","title":"get_modified_subclass_modules","text":"<pre><code>get_modified_subclass_modules(module, allowed_object_ids)\n</code></pre> <p>Assuming we are being passed the module where allowed_object_ids are defined, returns the direct subclasses of those objects.</p>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.is_port_open","title":"is_port_open","text":"<pre><code>is_port_open(host, port)\n</code></pre> <p>Check if a port is open on the given host.</p>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.mount_exceptions","title":"mount_exceptions","text":"<pre><code>mount_exceptions(app_controller)\n</code></pre>"},{"location":"api/watch_server/#mountaineer.app_manager.HotReloadManager.handle_dev_exception","title":"handle_dev_exception  <code>async</code>","text":"<pre><code>handle_dev_exception(request, exc)\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch.PackageWatchdog","title":"mountaineer.watch.PackageWatchdog","text":"<pre><code>PackageWatchdog(\n    main_package,\n    dependent_packages,\n    callbacks=None,\n    run_on_bootup=False,\n)\n</code></pre> PARAMETER DESCRIPTION <code>run_on_bootup</code> <p>Typically, we will only notify callback if there has been a change to the filesystem. If this is set to True, we will run all callbacks on bootup as well.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p>"},{"location":"api/watch_server/#mountaineer.watch.PackageWatchdog.main_package","title":"main_package  <code>instance-attribute</code>","text":"<pre><code>main_package = main_package\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch.PackageWatchdog.packages","title":"packages  <code>instance-attribute</code>","text":"<pre><code>packages = [main_package] + dependent_packages\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch.PackageWatchdog.paths","title":"paths  <code>instance-attribute</code>","text":"<pre><code>paths = []\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch.PackageWatchdog.callbacks","title":"callbacks  <code>instance-attribute</code>","text":"<pre><code>callbacks = callbacks or []\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch.PackageWatchdog.run_on_bootup","title":"run_on_bootup  <code>instance-attribute</code>","text":"<pre><code>run_on_bootup = run_on_bootup\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch.PackageWatchdog.event_handler","title":"event_handler  <code>instance-attribute</code>","text":"<pre><code>event_handler = None\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch.PackageWatchdog.observer","title":"observer  <code>instance-attribute</code>","text":"<pre><code>observer = None\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch.PackageWatchdog.start_watching","title":"start_watching","text":"<pre><code>start_watching()\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch.PackageWatchdog.check_packages_installed","title":"check_packages_installed","text":"<pre><code>check_packages_installed()\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch.PackageWatchdog.get_package_paths","title":"get_package_paths","text":"<pre><code>get_package_paths()\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch.PackageWatchdog.acquire_watchdog_lock","title":"acquire_watchdog_lock","text":"<pre><code>acquire_watchdog_lock()\n</code></pre> <p>We only want one watchdog running at a time or otherwise we risk stepping on each other or having infinitely looping file change notifications.</p>"},{"location":"api/watch_server/#mountaineer.watch.PackageWatchdog.merge_paths","title":"merge_paths","text":"<pre><code>merge_paths(raw_paths)\n</code></pre> <p>If one path is a subdirectory of another, we only want to watch the parent directory. This function merges the paths to avoid duplicate watchers.</p>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice","title":"mountaineer.watch_server.WatcherWebservice","text":"<pre><code>WatcherWebservice(webservice_host, webservice_port=None)\n</code></pre> <p>A simple webserver to notify frontends about updated builds.</p> <p>The WatcherWebservice provides a multiprocessing safe queue that's accessible as <code>notification_queue</code>. Each time that a process wants to update the frontend, it can push a message into the queue.</p>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app = build_app()\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice.websockets","title":"websockets  <code>instance-attribute</code>","text":"<pre><code>websockets = []\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice.host","title":"host  <code>instance-attribute</code>","text":"<pre><code>host = webservice_host\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port = webservice_port or get_free_port()\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice.notification_queue","title":"notification_queue  <code>instance-attribute</code>","text":"<pre><code>notification_queue = Queue()\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice.webservice_thread","title":"webservice_thread  <code>instance-attribute</code>","text":"<pre><code>webservice_thread = None\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice.monitor_build_thread","title":"monitor_build_thread  <code>instance-attribute</code>","text":"<pre><code>monitor_build_thread = None\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice.has_started","title":"has_started  <code>instance-attribute</code>","text":"<pre><code>has_started = False\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice.build_app","title":"build_app","text":"<pre><code>build_app()\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice.broadcast_listeners","title":"broadcast_listeners  <code>async</code>","text":"<pre><code>broadcast_listeners()\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice.monitor_builds","title":"monitor_builds","text":"<pre><code>monitor_builds()\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice.start","title":"start","text":"<pre><code>start()\n</code></pre>"},{"location":"api/watch_server/#mountaineer.watch_server.WatcherWebservice.stop","title":"stop","text":"<pre><code>stop(wait_for_completion=1)\n</code></pre> <p>Attempts to stop the separate WatcherWebservice threads. We will send a termination signal to the threads and wait the desired interval for full completion. If the threads haven't exited after the interval, we will return False. Clients can then decide whether to send a harder termination signal to terminate the threads on the OS level.</p>"},{"location":"api/build_plugins/base/","title":"Build Plugin Base","text":"<p>Use the <code>ClientBuilderBase</code> to implement a new stage or custom handling during the frontend build lifecycle. Note that this API is still under development and might change between minor Mountaineer versions.</p>"},{"location":"api/build_plugins/base/#mountaineer.client_compiler.base.ClientBuilderBase","title":"mountaineer.client_compiler.base.ClientBuilderBase","text":"<pre><code>ClientBuilderBase()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class for client builders. When mounted to an AppController, these build plugins will be called for every file defined in the view/app directory. It's up to the plugin whether to handle the incoming file.</p>"},{"location":"api/build_plugins/base/#mountaineer.client_compiler.base.ClientBuilderBase.metadata","title":"metadata  <code>instance-attribute</code>","text":"<pre><code>metadata = None\n</code></pre>"},{"location":"api/build_plugins/base/#mountaineer.client_compiler.base.ClientBuilderBase.dirty_files","title":"dirty_files  <code>instance-attribute</code>","text":"<pre><code>dirty_files = set()\n</code></pre>"},{"location":"api/build_plugins/base/#mountaineer.client_compiler.base.ClientBuilderBase.controllers","title":"controllers  <code>instance-attribute</code>","text":"<pre><code>controllers = []\n</code></pre>"},{"location":"api/build_plugins/base/#mountaineer.client_compiler.base.ClientBuilderBase.set_metadata","title":"set_metadata","text":"<pre><code>set_metadata(metadata)\n</code></pre>"},{"location":"api/build_plugins/base/#mountaineer.client_compiler.base.ClientBuilderBase.register_controller","title":"register_controller","text":"<pre><code>register_controller(controller, view_path)\n</code></pre>"},{"location":"api/build_plugins/base/#mountaineer.client_compiler.base.ClientBuilderBase.mark_file_dirty","title":"mark_file_dirty","text":"<pre><code>mark_file_dirty(file_path)\n</code></pre>"},{"location":"api/build_plugins/base/#mountaineer.client_compiler.base.ClientBuilderBase.build_wrapper","title":"build_wrapper  <code>async</code>","text":"<pre><code>build_wrapper()\n</code></pre> <p>All internal users should use this instead of .build()</p>"},{"location":"api/build_plugins/base/#mountaineer.client_compiler.base.ClientBuilderBase.build","title":"build  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>build()\n</code></pre> <p>Builds the dirty files.</p>"},{"location":"api/build_plugins/base/#mountaineer.client_compiler.base.ClientBuilderBase.managed_views_from_paths","title":"managed_views_from_paths","text":"<pre><code>managed_views_from_paths(paths)\n</code></pre> <p>Given a list of paths, assume these fall somewhere within the view directories specified by the controllers. Returns the ManagedViewPath objects for all paths where a match is found.</p>"},{"location":"api/build_plugins/postcss/","title":"PostCSS","text":""},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler","title":"mountaineer.client_compiler.postcss.PostCSSBundler","text":"<pre><code>PostCSSBundler(*args, **kwargs)\n</code></pre> <p>               Bases: <code>ClientBuilderBase</code></p> <p>Support PostCSS processing for CSS files.</p> <ul> <li>Assumes postcss-cli is installed in the primary project's package root (ie.   the ci_webapp/views/node_modules directory)</li> <li>Assumes that the css file under consideration has a root postcss.config.js file   within its own view path</li> </ul>"},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler.metadata","title":"metadata  <code>instance-attribute</code>","text":"<pre><code>metadata = None\n</code></pre>"},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler.dirty_files","title":"dirty_files  <code>instance-attribute</code>","text":"<pre><code>dirty_files = set()\n</code></pre>"},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler.controllers","title":"controllers  <code>instance-attribute</code>","text":"<pre><code>controllers = []\n</code></pre>"},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler.known_css_files","title":"known_css_files  <code>instance-attribute</code>","text":"<pre><code>known_css_files = set()\n</code></pre>"},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler.set_metadata","title":"set_metadata","text":"<pre><code>set_metadata(metadata)\n</code></pre>"},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler.register_controller","title":"register_controller","text":"<pre><code>register_controller(controller, view_path)\n</code></pre>"},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler.build_wrapper","title":"build_wrapper  <code>async</code>","text":"<pre><code>build_wrapper()\n</code></pre> <p>All internal users should use this instead of .build()</p>"},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler.managed_views_from_paths","title":"managed_views_from_paths","text":"<pre><code>managed_views_from_paths(paths)\n</code></pre> <p>Given a list of paths, assume these fall somewhere within the view directories specified by the controllers. Returns the ManagedViewPath objects for all paths where a match is found.</p>"},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler.mark_file_dirty","title":"mark_file_dirty","text":"<pre><code>mark_file_dirty(file_path)\n</code></pre>"},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler.build","title":"build  <code>async</code>","text":"<pre><code>build()\n</code></pre>"},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler.process_css","title":"process_css  <code>async</code>","text":"<pre><code>process_css(css_path)\n</code></pre> <p>Process a CSS file using PostCSS and output the transformed contents.</p>"},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler.get_style_output_name","title":"get_style_output_name","text":"<pre><code>get_style_output_name(original_stylesheet_path)\n</code></pre> <p>Given a path to an original stylesheet, return the name of the compiled css file</p> <p>original_stylesheet_path: \"path/to/styles.scss\" output: \"path_to_styles.css\"</p>"},{"location":"api/build_plugins/postcss/#mountaineer.client_compiler.postcss.PostCSSBundler.postcss_is_installed","title":"postcss_is_installed","text":"<pre><code>postcss_is_installed(view_root_path)\n</code></pre>"},{"location":"api/database/config/","title":"Database Config","text":""},{"location":"api/database/config/#mountaineer.database.config.DatabaseConfig","title":"mountaineer.database.config.DatabaseConfig","text":"<p>               Bases: <code>BaseSettings</code></p>"},{"location":"api/database/config/#mountaineer.database.config.DatabaseConfig.POSTGRES_HOST","title":"POSTGRES_HOST  <code>instance-attribute</code>","text":"<pre><code>POSTGRES_HOST\n</code></pre>"},{"location":"api/database/config/#mountaineer.database.config.DatabaseConfig.POSTGRES_USER","title":"POSTGRES_USER  <code>instance-attribute</code>","text":"<pre><code>POSTGRES_USER\n</code></pre>"},{"location":"api/database/config/#mountaineer.database.config.DatabaseConfig.POSTGRES_PASSWORD","title":"POSTGRES_PASSWORD  <code>instance-attribute</code>","text":"<pre><code>POSTGRES_PASSWORD\n</code></pre>"},{"location":"api/database/config/#mountaineer.database.config.DatabaseConfig.POSTGRES_DB","title":"POSTGRES_DB  <code>instance-attribute</code>","text":"<pre><code>POSTGRES_DB\n</code></pre>"},{"location":"api/database/config/#mountaineer.database.config.DatabaseConfig.POSTGRES_PORT","title":"POSTGRES_PORT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POSTGRES_PORT = 5432\n</code></pre>"},{"location":"api/database/config/#mountaineer.database.config.DatabaseConfig.SQLALCHEMY_DATABASE_URI","title":"SQLALCHEMY_DATABASE_URI  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SQLALCHEMY_DATABASE_URI = None\n</code></pre>"},{"location":"api/database/config/#mountaineer.database.config.DatabaseConfig.DATABASE_POOL_TYPE","title":"DATABASE_POOL_TYPE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATABASE_POOL_TYPE = NULL\n</code></pre>"},{"location":"api/database/config/#mountaineer.database.config.DatabaseConfig.build_db_connection","title":"build_db_connection","text":"<pre><code>build_db_connection(values)\n</code></pre>"},{"location":"api/database/dependencies/","title":"Database Dependencies","text":""},{"location":"api/database/dependencies/#mountaineer.database.DatabaseDependencies","title":"mountaineer.database.DatabaseDependencies","text":"<p>Database dependencies for use in API endpoint routes.</p>"},{"location":"api/database/migrations/","title":"Database Migrations","text":""},{"location":"api/database/migrations/#cli","title":"CLI","text":""},{"location":"api/database/migrations/#mountaineer.migrations.cli.handle_generate","title":"mountaineer.migrations.cli.handle_generate  <code>async</code>","text":"<pre><code>handle_generate(message=None)\n</code></pre> <p>Creates a new migration definition file, comparing the previous version (if it exists) with the current schema.</p>"},{"location":"api/database/migrations/#mountaineer.migrations.cli.handle_apply","title":"mountaineer.migrations.cli.handle_apply  <code>async</code>","text":"<pre><code>handle_apply()\n</code></pre> <p>Applies all migrations that have not been applied to the database.</p>"},{"location":"api/database/migrations/#mountaineer.migrations.cli.handle_rollback","title":"mountaineer.migrations.cli.handle_rollback  <code>async</code>","text":"<pre><code>handle_rollback()\n</code></pre> <p>Rolls back the last migration that was applied to the database.</p>"},{"location":"api/database/migrations/#migrations","title":"Migrations","text":""},{"location":"api/database/migrations/#mountaineer.migrations.migration.MigrationRevisionBase","title":"mountaineer.migrations.migration.MigrationRevisionBase","text":"<p>Base class for all revisions. Both the \"up\" and the \"down\" also accepts all dependency injection values.</p>"},{"location":"api/database/migrations/#mountaineer.migrations.migration.MigrationRevisionBase.up_revision","title":"up_revision  <code>instance-attribute</code>","text":"<pre><code>up_revision\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.migration.MigrationRevisionBase.down_revision","title":"down_revision  <code>instance-attribute</code>","text":"<pre><code>down_revision\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.migration.MigrationRevisionBase.handle_up","title":"handle_up  <code>async</code>","text":"<pre><code>handle_up()\n</code></pre> <p>Internal method to handle the up migration.</p>"},{"location":"api/database/migrations/#mountaineer.migrations.migration.MigrationRevisionBase.handle_down","title":"handle_down  <code>async</code>","text":"<pre><code>handle_down()\n</code></pre> <p>Internal method to handle the down migration.</p>"},{"location":"api/database/migrations/#mountaineer.migrations.migration.MigrationRevisionBase.up","title":"up  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>up(migrator)\n</code></pre> <p>Perform the migration \"up\" action. Clients should place their migration logic here.</p>"},{"location":"api/database/migrations/#mountaineer.migrations.migration.MigrationRevisionBase.down","title":"down  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>down(migrator)\n</code></pre> <p>Perform the migration \"down\" action. Clients should place their migration logic here.</p>"},{"location":"api/database/migrations/#mountaineer.migrations.migrator.Migrator","title":"mountaineer.migrations.migrator.Migrator","text":"<pre><code>Migrator(db_session)\n</code></pre> <p>Main interface for client migrations. Mountaineer provides a simple shim on top of common database migration options within <code>migrator.actor</code>. This lets you add columns, drop columns, migrate types, and the like. For more complex migrations, you can use the <code>migrator.db_session</code> to run raw SQL queries within the current migration transaction.</p>"},{"location":"api/database/migrations/#mountaineer.migrations.migrator.Migrator.actor","title":"actor  <code>instance-attribute</code>","text":"<pre><code>actor = DatabaseActions(\n    dry_run=False, db_session=db_session\n)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.migrator.Migrator.db_session","title":"db_session  <code>instance-attribute</code>","text":"<pre><code>db_session = db_session\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.migrator.Migrator.new_migrator","title":"new_migrator  <code>async</code> <code>classmethod</code>","text":"<pre><code>new_migrator(db_engine)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.migrator.Migrator.init_db","title":"init_db  <code>async</code>","text":"<pre><code>init_db()\n</code></pre> <p>Initialize our migration management table if it doesn't already exist within the attached postgres database. This will be a no-op if the table already exists.</p> <p>Client callers should call this method once before running any migrations.</p>"},{"location":"api/database/migrations/#mountaineer.migrations.migrator.Migrator.set_active_revision","title":"set_active_revision  <code>async</code>","text":"<pre><code>set_active_revision(value)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.migrator.Migrator.get_active_revision","title":"get_active_revision  <code>async</code>","text":"<pre><code>get_active_revision()\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.migrator.NoCommitAsyncSession","title":"mountaineer.migrations.migrator.NoCommitAsyncSession","text":"<pre><code>NoCommitAsyncSession(*args, **kwargs)\n</code></pre> <p>               Bases: <code>AsyncSession</code></p> <p>To be safe in case of an error and rollback, migrations must be run in an isolated transaction and shouldn't be committed. This class is a simple wrapper around <code>AsyncSession</code> that will prevent commits.</p>"},{"location":"api/database/migrations/#mountaineer.migrations.migrator.NoCommitAsyncSession.okay_to_commit","title":"okay_to_commit  <code>instance-attribute</code>","text":"<pre><code>okay_to_commit = False\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.migrator.NoCommitAsyncSession.exec","title":"exec  <code>async</code>","text":"<pre><code>exec(\n    statement,\n    *,\n    params=None,\n    execution_options=util.EMPTY_DICT,\n    bind_arguments=None,\n    _parent_execute_state=None,\n    _add_event=None\n)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.migrator.NoCommitAsyncSession.commit","title":"commit  <code>async</code>","text":"<pre><code>commit()\n</code></pre>"},{"location":"api/database/migrations/#actions","title":"Actions","text":""},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions","title":"mountaineer.migrations.actions.DatabaseActions","text":"<pre><code>DatabaseActions(dry_run=True, db_session=None)\n</code></pre> <p>Track the actions that need to be executed to the database. Provides a shallow, typed ORM on top of the raw SQL commands that we'll execute through sqlalchemy.</p> <p>This class manually builds up the SQL strings that will be executed against postgres. We intentionally avoid using the ORM or variable-insertion modes here because most table-schema operations don't permit parameters to specify top-level SQL syntax. To keep things consistent, we'll use the same SQL string interpolation for all operations.</p>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.dry_run","title":"dry_run  <code>instance-attribute</code>","text":"<pre><code>dry_run = dry_run\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.dry_run_actions","title":"dry_run_actions  <code>instance-attribute</code>","text":"<pre><code>dry_run_actions = []\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.db_session","title":"db_session  <code>instance-attribute</code>","text":"<pre><code>db_session = db_session\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.prod_sqls","title":"prod_sqls  <code>instance-attribute</code>","text":"<pre><code>prod_sqls = []\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.add_table","title":"add_table  <code>async</code>","text":"<pre><code>add_table(table_name)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.drop_table","title":"drop_table  <code>async</code>","text":"<pre><code>drop_table(table_name)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.add_column","title":"add_column  <code>async</code>","text":"<pre><code>add_column(\n    table_name,\n    column_name,\n    explicit_data_type=None,\n    explicit_data_is_list=False,\n    custom_data_type=None,\n)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.drop_column","title":"drop_column  <code>async</code>","text":"<pre><code>drop_column(table_name, column_name)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.rename_column","title":"rename_column  <code>async</code>","text":"<pre><code>rename_column(table_name, old_column_name, new_column_name)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.modify_column_type","title":"modify_column_type  <code>async</code>","text":"<pre><code>modify_column_type(\n    table_name,\n    column_name,\n    explicit_data_type=None,\n    explicit_data_is_list=False,\n    custom_data_type=None,\n)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.add_constraint","title":"add_constraint  <code>async</code>","text":"<pre><code>add_constraint(\n    table_name,\n    columns,\n    constraint,\n    constraint_name,\n    constraint_args=None,\n)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.drop_constraint","title":"drop_constraint  <code>async</code>","text":"<pre><code>drop_constraint(table_name, constraint_name)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.add_index","title":"add_index  <code>async</code>","text":"<pre><code>add_index(table_name, columns, index_name)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.drop_index","title":"drop_index  <code>async</code>","text":"<pre><code>drop_index(table_name, index_name)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.add_not_null","title":"add_not_null  <code>async</code>","text":"<pre><code>add_not_null(table_name, column_name)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.drop_not_null","title":"drop_not_null  <code>async</code>","text":"<pre><code>drop_not_null(table_name, column_name)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.add_type","title":"add_type  <code>async</code>","text":"<pre><code>add_type(type_name, values)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.add_type_values","title":"add_type_values  <code>async</code>","text":"<pre><code>add_type_values(type_name, values)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.drop_type_values","title":"drop_type_values  <code>async</code>","text":"<pre><code>drop_type_values(type_name, values, target_columns)\n</code></pre> <p>Dropping values from an existing type isn't natively supported by Postgres. We work around this limitation by specifying the \"target_columns\" that already reference the enum type that we want to drop.</p> PARAMETER DESCRIPTION <code>target_columns</code> <p>Specified tuples of (table_name, column_name) pairs that should be migrated to the new enum value.</p> <p> TYPE: <code>list[tuple[str, str]]</code> </p>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.drop_type","title":"drop_type  <code>async</code>","text":"<pre><code>drop_type(type_name)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.DatabaseActions.add_comment","title":"add_comment","text":"<pre><code>add_comment(text)\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType","title":"mountaineer.migrations.actions.ColumnType","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.__str__","title":"__str__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__str__ = __str__\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.SMALLINT","title":"SMALLINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SMALLINT = 'smallint'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.INTEGER","title":"INTEGER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTEGER = 'integer'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.BIGINT","title":"BIGINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIGINT = 'bigint'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.DECIMAL","title":"DECIMAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DECIMAL = 'decimal'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.NUMERIC","title":"NUMERIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NUMERIC = 'numeric'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.REAL","title":"REAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REAL = 'real'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.DOUBLE_PRECISION","title":"DOUBLE_PRECISION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DOUBLE_PRECISION = 'double precision'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.SERIAL","title":"SERIAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SERIAL = 'serial'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.BIGSERIAL","title":"BIGSERIAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIGSERIAL = 'bigserial'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.MONEY","title":"MONEY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MONEY = 'money'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.CHAR","title":"CHAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHAR = 'char'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.VARCHAR","title":"VARCHAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VARCHAR = 'character varying'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.TEXT","title":"TEXT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TEXT = 'text'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.BYTEA","title":"BYTEA  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BYTEA = 'bytea'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.DATE","title":"DATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATE = 'date'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.TIME","title":"TIME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TIME = 'time'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.TIME_WITH_TIME_ZONE","title":"TIME_WITH_TIME_ZONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TIME_WITH_TIME_ZONE = 'time with time zone'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.TIMESTAMP","title":"TIMESTAMP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TIMESTAMP = 'timestamp'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.TIMESTAMP_WITH_TIME_ZONE","title":"TIMESTAMP_WITH_TIME_ZONE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TIMESTAMP_WITH_TIME_ZONE = 'timestamp with time zone'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.INTERVAL","title":"INTERVAL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INTERVAL = 'interval'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.BOOLEAN","title":"BOOLEAN  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOOLEAN = 'boolean'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.POINT","title":"POINT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POINT = 'point'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.LINE","title":"LINE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LINE = 'line'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.LSEG","title":"LSEG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LSEG = 'lseg'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.BOX","title":"BOX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BOX = 'box'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.PATH","title":"PATH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PATH = 'path'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.POLYGON","title":"POLYGON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>POLYGON = 'polygon'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.CIRCLE","title":"CIRCLE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CIRCLE = 'circle'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.CIDR","title":"CIDR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CIDR = 'cidr'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.INET","title":"INET  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INET = 'inet'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.MACADDR","title":"MACADDR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MACADDR = 'macaddr'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.MACADDR8","title":"MACADDR8  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MACADDR8 = 'macaddr8'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.BIT","title":"BIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIT = 'bit'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.BIT_VARYING","title":"BIT_VARYING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BIT_VARYING = 'bit varying'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.TSVECTOR","title":"TSVECTOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TSVECTOR = 'tsvector'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.TSQUERY","title":"TSQUERY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TSQUERY = 'tsquery'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.UUID","title":"UUID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UUID = 'uuid'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.XML","title":"XML  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>XML = 'xml'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.JSON","title":"JSON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JSON = 'json'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.JSONB","title":"JSONB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>JSONB = 'jsonb'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.INT4RANGE","title":"INT4RANGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INT4RANGE = 'int4range'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.NUMRANGE","title":"NUMRANGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NUMRANGE = 'numrange'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.TSRANGE","title":"TSRANGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TSRANGE = 'tsrange'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.TSTZRANGE","title":"TSTZRANGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TSTZRANGE = 'tstzrange'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.DATERANGE","title":"DATERANGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DATERANGE = 'daterange'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.OID","title":"OID  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>OID = 'oid'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ColumnType.__new__","title":"__new__","text":"<pre><code>__new__(*values)\n</code></pre> <p>values must already be of type <code>str</code></p>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ConstraintType","title":"mountaineer.migrations.actions.ConstraintType","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ConstraintType.__str__","title":"__str__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__str__ = __str__\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ConstraintType.PRIMARY_KEY","title":"PRIMARY_KEY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRIMARY_KEY = 'PRIMARY KEY'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ConstraintType.FOREIGN_KEY","title":"FOREIGN_KEY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FOREIGN_KEY = 'FOREIGN KEY'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ConstraintType.UNIQUE","title":"UNIQUE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNIQUE = 'UNIQUE'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ConstraintType.CHECK","title":"CHECK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CHECK = 'CHECK'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ConstraintType.INDEX","title":"INDEX  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INDEX = 'INDEX'\n</code></pre>"},{"location":"api/database/migrations/#mountaineer.migrations.actions.ConstraintType.__new__","title":"__new__","text":"<pre><code>__new__(*values)\n</code></pre> <p>values must already be of type <code>str</code></p>"},{"location":"internal/core_library/","title":"Core Library","text":"<p>Miscellaneous notes on development and testing the core library.</p>"},{"location":"internal/core_library/#installation","title":"Installation","text":"<p>When doing local development work, use poetry to manage dependencies and maturin to create a build of the combined python/rust project:</p> <pre><code>make install-deps\n</code></pre> <p>This effectively expands to:</p> <pre><code>poetry install\npoetry run maturin develop --release\n</code></pre> <p>You can also run maturin just with <code>poetry run maturin develop</code>, which will be much faster to compile, but rust execution will be notably slower.</p> <p>You'll also need a system-wide installation of esbuild. If you don't have one when you run the build pipline it will install one for you within <code>~/.cache/mountaineer/esbuild</code>.</p>"},{"location":"internal/core_library/#external-application","title":"External Application","text":"<p>If you want to test your mountaineer changes against a real webapp, you can build a wheel and then add it to your project's virtual environment:</p> <pre><code>$ poetry run maturin build --release\n\n   Finished `release` profile [optimized] target(s) in 51.28s\n\ud83d\udce6 Built wheel for CPython 3.12 to /Users/piercefreeman/projects/mountaineer/target/wheels/mountaineer-0.1.0-cp312-cp312-macosx_11_0_arm64.whl\n</code></pre> <p>Then, in your other project. If you've already installed a previous local mountaineer wheel, you'll have to run with <code>--force-reinstall</code> to prompt pip to actually swap out the wheels versus ignoring the same version number.</p> <pre><code>poetry run pip install [--force-reinstall] /Users/piercefreeman/projects/mountaineer/target/wheels/mountaineer-0.1.0-cp312-cp312-macosx_11_0_arm64.whl\n</code></pre>"},{"location":"internal/core_library/#logging","title":"Logging","text":"<p>It's sometimes helpful to run Mountaineer with verbose logging, whether you're developing new functionality or trying to diagnose a problem. You can set the <code>MOUNTAINEER_LOG_LEVEL</code> environment variable to <code>DEBUG</code> to enable verbose logging:</p> <pre><code>$ MOUNTAINEER_LOG_LEVEL=DEBUG poetry run runserver\n</code></pre>"},{"location":"internal/core_library/#development-utilities","title":"Development Utilities","text":"<ol> <li> <p>Python Testing</p> <pre><code>$ make test\n</code></pre> <p>During testing we also support providing additional test-args that are passed to pytest. This helps you narrow down the scope of tests, add more verbosity, etc.:</p> <pre><code>$ make test test-args=\"-k test_extracts_iterable\"\n</code></pre> </li> <li> <p>Python Linting</p> <pre><code>$ make lint\n</code></pre> </li> <li> <p>Rust Benchmarking</p> <pre><code>$ cargo bench\n</code></pre> </li> <li> <p>Diagnose errors in CI</p> <p>At the moment, our main CI testing flows run on Linux/x86-64 architectures. We've observed some behavior there that isn't reproducable locally. To test locally on OS X you'll need build a representative docker image and then test within it:</p> <p>```bash $ docker build -t mountaineer . $ docker run -it mountaineer $ make install-deps $ make test-integrations</p> </li> </ol>"}]}